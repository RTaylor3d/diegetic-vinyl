{
  "version": 3,
  "sources": ["../../music-metadata/lib/mpeg/MpegParser.js", "../../music-metadata/lib/mpeg/ReplayGainDataFormat.js", "../../music-metadata/lib/mpeg/ExtendedLameHeader.js", "../../music-metadata/lib/mpeg/XingTag.js"],
  "sourcesContent": ["import * as Token from 'token-types';\r\nimport { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport * as common from '../common/Util.js';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { InfoTagHeaderTag, LameEncoderVersion, readXingHeader } from './XingTag.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:mpeg');\r\nexport class MpegContentError extends makeUnexpectedFileContentError('MPEG') {\r\n}\r\n/**\r\n * Cache buffer size used for searching synchronization preabmle\r\n */\r\nconst maxPeekLen = 1024;\r\n/**\r\n * MPEG-4 Audio definitions\r\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\r\n */\r\nconst MPEG4 = {\r\n    /**\r\n     * Audio Object Types\r\n     */\r\n    AudioObjectTypes: [\r\n        'AAC Main',\r\n        'AAC LC', // Low Complexity\r\n        'AAC SSR', // Scalable Sample Rate\r\n        'AAC LTP' // Long Term Prediction\r\n    ],\r\n    /**\r\n     * Sampling Frequencies\r\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\r\n     */\r\n    SamplingFrequencies: [\r\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1\r\n    ]\r\n    /**\r\n     * Channel Configurations\r\n     */\r\n};\r\nconst MPEG4_ChannelConfigurations = [\r\n    undefined,\r\n    ['front-center'],\r\n    ['front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-center'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\r\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III frame header\r\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\r\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\r\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\r\n */\r\nclass MpegFrameHeader {\r\n    constructor(buf, off) {\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = null;\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = null;\r\n        // G(9): Padding bit\r\n        this.padding = null;\r\n        // H(8): Private bit\r\n        this.privateBit = null;\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = null;\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = null;\r\n        // L(2): Original\r\n        this.isOriginalMedia = null;\r\n        this.version = null;\r\n        this.bitrate = null;\r\n        this.samplingRate = null;\r\n        this.frameLength = 0;\r\n        // B(20,19): MPEG Audio versionIndex ID\r\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\r\n        // C(18,17): Layer description\r\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\r\n        if (this.versionIndex > 1 && this.layer === 0) {\r\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\r\n        }\r\n        else {\r\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\r\n        }\r\n        // D(16): Protection bit (if true 16-bit CRC follows header)\r\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\r\n    }\r\n    calcDuration(numFrames) {\r\n        return this.samplingRate == null ? null : (numFrames * this.calcSamplesPerFrame() / this.samplingRate);\r\n    }\r\n    calcSamplesPerFrame() {\r\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\r\n    }\r\n    calculateSideInfoLength() {\r\n        if (this.layer !== 3)\r\n            return 2;\r\n        if (this.channelModeIndex === 3) {\r\n            // mono\r\n            if (this.version === 1) {\r\n                return 17;\r\n            }\r\n            if (this.version === 2 || this.version === 2.5) {\r\n                return 9;\r\n            }\r\n        }\r\n        else {\r\n            if (this.version === 1) {\r\n                return 32;\r\n            }\r\n            if (this.version === 2 || this.version === 2.5) {\r\n                return 17;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    calcSlotSize() {\r\n        return [null, 4, 1, 1][this.layer];\r\n    }\r\n    parseMpegHeader(buf, off) {\r\n        this.container = 'MPEG';\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\r\n        // G(9): Padding bit\r\n        this.padding = common.isBitSet(buf, off + 2, 6);\r\n        // H(8): Private bit\r\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\r\n        // K(3): Copyright\r\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\r\n        // L(2): Original\r\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\r\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\r\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\r\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\r\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\r\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\r\n        // Calculate bitrate\r\n        const bitrateInKbps = this.calcBitrate();\r\n        if (!bitrateInKbps) {\r\n            throw new MpegContentError('Cannot determine bit-rate');\r\n        }\r\n        this.bitrate = bitrateInKbps * 1000;\r\n        // Calculate sampling rate\r\n        this.samplingRate = this.calcSamplingRate();\r\n        if (this.samplingRate == null) {\r\n            throw new MpegContentError('Cannot determine sampling-rate');\r\n        }\r\n    }\r\n    parseAdtsHeader(buf, off) {\r\n        debug(\"layer=0 => ADTS\");\r\n        this.version = this.versionIndex === 2 ? 4 : 2;\r\n        this.container = `ADTS/MPEG-${this.version}`;\r\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\r\n        this.codec = 'AAC';\r\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\r\n        debug(`MPEG-4 audio-codec=${this.codec}`);\r\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\r\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\r\n        debug(`sampling-rate=${this.samplingRate}`);\r\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\r\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\r\n        debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);\r\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\r\n    }\r\n    calcBitrate() {\r\n        if (this.bitrateIndex === 0x00 || // free\r\n            this.bitrateIndex === 0x0F) { // reserved\r\n            return null;\r\n        }\r\n        if (this.version && this.bitrateIndex) {\r\n            const codecIndex = 10 * Math.floor(this.version) + this.layer;\r\n            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\r\n        }\r\n        return null;\r\n    }\r\n    calcSamplingRate() {\r\n        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null)\r\n            return null; // 'reserved'\r\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\r\n    }\r\n}\r\nMpegFrameHeader.SyncByte1 = 0xFF;\r\nMpegFrameHeader.SyncByte2 = 0xE0;\r\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\r\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\r\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\r\nMpegFrameHeader.bitrate_index = {\r\n    1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\r\n    2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\r\n    3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\r\n    4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\r\n    5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\r\n    6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\r\n    7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\r\n    8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\r\n    9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\r\n    10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\r\n    11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\r\n    12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\r\n    13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\r\n    14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\r\n};\r\nMpegFrameHeader.sampling_rate_freq_index = {\r\n    1: { 0: 44100, 1: 48000, 2: 32000 },\r\n    2: { 0: 22050, 1: 24000, 2: 16000 },\r\n    2.5: { 0: 11025, 1: 12000, 2: 8000 }\r\n};\r\nMpegFrameHeader.samplesInFrameTable = [\r\n    /* Layer   I    II   III */\r\n    [0, 384, 1152, 1152], // MPEG-1\r\n    [0, 384, 1152, 576] // MPEG-2(.5\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III\r\n */\r\nconst FrameHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return new MpegFrameHeader(buf, off);\r\n    }\r\n};\r\nfunction getVbrCodecProfile(vbrScale) {\r\n    return `V${Math.floor((100 - vbrScale) / 10)}`;\r\n}\r\nexport class MpegParser extends AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.frameCount = 0;\r\n        this.syncFrameCount = -1;\r\n        this.countSkipFrameData = 0;\r\n        this.totalDataLength = 0;\r\n        this.bitrates = [];\r\n        this.offset = 0;\r\n        this.frame_size = 0;\r\n        this.crc = null;\r\n        this.calculateEofDuration = false;\r\n        this.samplesPerFrame = null;\r\n        this.buf_frame_header = new Uint8Array(4);\r\n        /**\r\n         * Number of bytes already parsed since beginning of stream / file\r\n         */\r\n        this.mpegOffset = null;\r\n        this.syncPeek = {\r\n            buf: new Uint8Array(maxPeekLen),\r\n            len: 0\r\n        };\r\n    }\r\n    /**\r\n     * Called after ID3 headers have been parsed\r\n     */\r\n    async postId3v2Parse() {\r\n        this.metadata.setFormat('lossless', false);\r\n        try {\r\n            let quit = false;\r\n            while (!quit) {\r\n                await this.sync();\r\n                quit = await this.parseCommonMpegHeader();\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n                if (this.calculateEofDuration) {\r\n                    if (this.samplesPerFrame !== null) {\r\n                        const numberOfSamples = this.frameCount * this.samplesPerFrame;\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        if (this.metadata.format.sampleRate) {\r\n                            const duration = numberOfSamples / this.metadata.format.sampleRate;\r\n                            debug(`Calculate duration at EOF: ${duration} sec.`, duration);\r\n                            this.metadata.setFormat('duration', duration);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\r\n     */\r\n    finalize() {\r\n        const format = this.metadata.format;\r\n        const hasID3v1 = !!this.metadata.native.ID3v1;\r\n        if (this.mpegOffset !== null) {\r\n            if (format.duration && this.tokenizer.fileInfo.size) {\r\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n                if (format.codecProfile && format.codecProfile[0] === 'V') {\r\n                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\r\n                }\r\n            }\r\n            if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\r\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n                if (this.frame_size !== null && this.samplesPerFrame !== null) {\r\n                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\r\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                    if (format.sampleRate && !format.duration) {\r\n                        const duration = numberOfSamples / format.sampleRate;\r\n                        debug(\"Calculate CBR duration based on file size: %s\", duration);\r\n                        this.metadata.setFormat('duration', duration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async sync() {\r\n        let gotFirstSync = false;\r\n        while (true) {\r\n            let bo = 0;\r\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\r\n            if (this.syncPeek.len <= 163) {\r\n                throw new EndOfStreamError();\r\n            }\r\n            while (true) {\r\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\r\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\r\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\r\n                    await this.tokenizer.ignore(bo);\r\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\r\n                    if (this.syncFrameCount === this.frameCount) {\r\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\r\n                        this.frameCount = 0;\r\n                        this.frame_size = 0;\r\n                    }\r\n                    this.syncFrameCount = this.frameCount;\r\n                    return; // sync\r\n                }\r\n                gotFirstSync = false;\r\n                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\r\n                if (bo === -1) {\r\n                    if (this.syncPeek.len < this.syncPeek.buf.length) {\r\n                        throw new EndOfStreamError();\r\n                    }\r\n                    await this.tokenizer.ignore(this.syncPeek.len);\r\n                    break; // continue with next buffer\r\n                }\r\n                ++bo;\r\n                gotFirstSync = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseCommonMpegHeader() {\r\n        if (this.frameCount === 0) {\r\n            this.mpegOffset = this.tokenizer.position - 1;\r\n        }\r\n        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });\r\n        let header;\r\n        try {\r\n            header = FrameHeader.get(this.buf_frame_header, 0);\r\n        }\r\n        catch (err) {\r\n            await this.tokenizer.ignore(1);\r\n            if (err instanceof Error) {\r\n                this.metadata.addWarning(`Parse error: ${err.message}`);\r\n                return false; // sync\r\n            }\r\n            throw err;\r\n        }\r\n        await this.tokenizer.ignore(3);\r\n        this.metadata.setFormat('container', header.container);\r\n        this.metadata.setFormat('codec', header.codec);\r\n        this.metadata.setFormat('lossless', false);\r\n        this.metadata.setFormat('sampleRate', header.samplingRate);\r\n        this.frameCount++;\r\n        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\r\n    }\r\n    /**\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseAudioFrameHeader(header) {\r\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\r\n        this.metadata.setFormat('bitrate', header.bitrate);\r\n        if (this.frameCount < 20 * 10000) {\r\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\r\n        }\r\n        const slot_size = header.calcSlotSize();\r\n        if (slot_size === null) {\r\n            throw new MpegContentError('invalid slot_size');\r\n        }\r\n        const samples_per_frame = header.calcSamplesPerFrame();\r\n        debug(`samples_per_frame=${samples_per_frame}`);\r\n        const bps = samples_per_frame / 8.0;\r\n        if (header.bitrate !== null && header.samplingRate != null) {\r\n            const fsize = (bps * header.bitrate / header.samplingRate) + ((header.padding) ? slot_size : 0);\r\n            this.frame_size = Math.floor(fsize);\r\n        }\r\n        this.audioFrameHeader = header;\r\n        if (header.bitrate !== null) {\r\n            this.bitrates.push(header.bitrate);\r\n        }\r\n        // xtra header only exists in first frame\r\n        if (this.frameCount === 1) {\r\n            this.offset = FrameHeader.len;\r\n            await this.skipSideInformation();\r\n            return false;\r\n        }\r\n        if (this.frameCount === 3) {\r\n            // the stream is CBR if the first 3 frame bitrates are the same\r\n            if (this.areAllSame(this.bitrates)) {\r\n                // Actual calculation will be done in finalize\r\n                this.samplesPerFrame = samples_per_frame;\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                if (this.tokenizer.fileInfo.size)\r\n                    return true; // Will calculate duration based on the file size\r\n            }\r\n            else if (this.metadata.format.duration) {\r\n                return true; // We already got the duration, stop processing MPEG stream any further\r\n            }\r\n            if (!this.options.duration) {\r\n                return true; // Enforce duration not enabled, stop processing entire stream\r\n            }\r\n        }\r\n        // once we know the file is VBR attach listener to end of\r\n        // stream so we can do the duration calculation when we\r\n        // have counted all the frames\r\n        if (this.options.duration && this.frameCount === 4) {\r\n            this.samplesPerFrame = samples_per_frame;\r\n            this.calculateEofDuration = true;\r\n        }\r\n        this.offset = 4;\r\n        if (header.isProtectedByCRC) {\r\n            await this.parseCrc();\r\n            return false;\r\n        }\r\n        await this.skipSideInformation();\r\n        return false;\r\n    }\r\n    async parseAdts(header) {\r\n        const buf = new Uint8Array(3);\r\n        await this.tokenizer.readBuffer(buf);\r\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\r\n        this.totalDataLength += header.frameLength;\r\n        this.samplesPerFrame = 1024;\r\n        if (header.samplingRate !== null) {\r\n            const framesPerSec = header.samplingRate / this.samplesPerFrame;\r\n            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\r\n            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\r\n            this.metadata.setFormat('bitrate', bitrate);\r\n            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\r\n        }\r\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\r\n        // Consume remaining header and frame data\r\n        if (this.frameCount === 3) {\r\n            this.metadata.setFormat('codecProfile', header.codecProfile);\r\n            if (header.mp4ChannelConfig) {\r\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\r\n            }\r\n            if (this.options.duration) {\r\n                this.calculateEofDuration = true;\r\n            }\r\n            else {\r\n                return true; // Stop parsing after the third frame\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    async parseCrc() {\r\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\r\n        this.offset += 2;\r\n        return this.skipSideInformation();\r\n    }\r\n    async skipSideInformation() {\r\n        if (this.audioFrameHeader) {\r\n            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\r\n            if (sideinfo_length !== null) {\r\n                await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\r\n                // side information\r\n                this.offset += sideinfo_length;\r\n                await this.readXtraInfoHeader();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    async readXtraInfoHeader() {\r\n        const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);\r\n        this.offset += InfoTagHeaderTag.len; // 12\r\n        switch (headerTag) {\r\n            case 'Info':\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                return this.readXingInfoHeader();\r\n            case 'Xing': {\r\n                const infoTag = await this.readXingInfoHeader();\r\n                if (infoTag.vbrScale !== null) {\r\n                    const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\r\n                    this.metadata.setFormat('codecProfile', codecProfile);\r\n                }\r\n                return null;\r\n            }\r\n            case 'Xtra':\r\n                // ToDo: ???\r\n                break;\r\n            case 'LAME': {\r\n                const version = await this.tokenizer.readToken(LameEncoderVersion);\r\n                if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {\r\n                    this.offset += LameEncoderVersion.len;\r\n                    this.metadata.setFormat('tool', `LAME ${version}`);\r\n                    await this.skipFrameData(this.frame_size - this.offset);\r\n                    return null;\r\n                }\r\n                this.metadata.addWarning('Corrupt LAME header');\r\n                break;\r\n            }\r\n            // ToDo: ???\r\n        }\r\n        // ToDo: promise duration???\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        if (frameDataLeft < 0) {\r\n            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);\r\n        }\r\n        else {\r\n            await this.skipFrameData(frameDataLeft);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n     * @returns {Promise<string>}\r\n     */\r\n    async readXingInfoHeader() {\r\n        const offset = this.tokenizer.position;\r\n        const infoTag = await readXingHeader(this.tokenizer);\r\n        this.offset += this.tokenizer.position - offset;\r\n        if (infoTag.lame) {\r\n            this.metadata.setFormat('tool', `LAME ${common.stripNulls(infoTag.lame.version)}`);\r\n            if (infoTag.lame.extended) {\r\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\r\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\r\n                if (infoTag.lame.extended.track_gain) {\r\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\r\n                }\r\n                if (infoTag.lame.extended.album_gain) {\r\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\r\n                }\r\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\r\n            }\r\n        }\r\n        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {\r\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\r\n            this.metadata.setFormat('duration', duration);\r\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\r\n            return infoTag;\r\n        }\r\n        // frames field is not present\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        await this.skipFrameData(frameDataLeft);\r\n        return infoTag;\r\n    }\r\n    async skipFrameData(frameDataLeft) {\r\n        if (frameDataLeft < 0)\r\n            throw new MpegContentError('frame-data-left cannot be negative');\r\n        await this.tokenizer.ignore(frameDataLeft);\r\n        this.countSkipFrameData += frameDataLeft;\r\n    }\r\n    areAllSame(array) {\r\n        const first = array[0];\r\n        return array.every(element => {\r\n            return element === first;\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=MpegParser.js.map", "import * as common from '../common/Util.js';\r\n/**\r\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code\r\n */\r\nvar NameCode;\r\n(function (NameCode) {\r\n    /**\r\n     * not set\r\n     */\r\n    NameCode[NameCode[\"not_set\"] = 0] = \"not_set\";\r\n    /**\r\n     * Radio Gain Adjustment\r\n     */\r\n    NameCode[NameCode[\"radio\"] = 1] = \"radio\";\r\n    /**\r\n     * Audiophile Gain Adjustment\r\n     */\r\n    NameCode[NameCode[\"audiophile\"] = 2] = \"audiophile\";\r\n})(NameCode || (NameCode = {}));\r\n/**\r\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code\r\n */\r\nvar ReplayGainOriginator;\r\n(function (ReplayGainOriginator) {\r\n    /**\r\n     * Replay Gain unspecified\r\n     */\r\n    ReplayGainOriginator[ReplayGainOriginator[\"unspecified\"] = 0] = \"unspecified\";\r\n    /**\r\n     * Replay Gain pre-set by artist/producer/mastering engineer\r\n     */\r\n    ReplayGainOriginator[ReplayGainOriginator[\"engineer\"] = 1] = \"engineer\";\r\n    /**\r\n     * Replay Gain set by user\r\n     */\r\n    ReplayGainOriginator[ReplayGainOriginator[\"user\"] = 2] = \"user\";\r\n    /**\r\n     * Replay Gain determined automatically, as described on this site\r\n     */\r\n    ReplayGainOriginator[ReplayGainOriginator[\"automatic\"] = 3] = \"automatic\";\r\n    /**\r\n     * Set by simple RMS average\r\n     */\r\n    ReplayGainOriginator[ReplayGainOriginator[\"rms_average\"] = 4] = \"rms_average\";\r\n})(ReplayGainOriginator || (ReplayGainOriginator = {}));\r\n/**\r\n * Replay Gain Data Format\r\n *\r\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format\r\n */\r\nexport const ReplayGain = {\r\n    len: 2,\r\n    get: (buf, off) => {\r\n        const gain_type = common.getBitAllignedNumber(buf, off, 0, 3);\r\n        const sign = common.getBitAllignedNumber(buf, off, 6, 1);\r\n        const gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10.0;\r\n        if (gain_type > 0) {\r\n            return {\r\n                type: common.getBitAllignedNumber(buf, off, 0, 3),\r\n                origin: common.getBitAllignedNumber(buf, off, 3, 3),\r\n                adjustment: (sign ? -gain_adj : gain_adj)\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n};\r\n//# sourceMappingURL=ReplayGainDataFormat.js.map", "/**\r\n * Extended Lame Header\r\n */\r\nimport * as Token from 'token-types';\r\nimport * as common from '../common/Util.js';\r\nimport { ReplayGain } from './ReplayGainDataFormat.js';\r\n/**\r\n * Info Tag\r\n * @link http://gabriel.mp3-tech.org/mp3infotag.html\r\n * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112\r\n */\r\nexport const ExtendedLameHeader = {\r\n    len: 27,\r\n    get: (buf, off) => {\r\n        const track_peak = Token.UINT32_BE.get(buf, off + 2);\r\n        return {\r\n            revision: common.getBitAllignedNumber(buf, off, 0, 4),\r\n            vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),\r\n            lowpass_filter: 100 * Token.UINT8.get(buf, off + 1),\r\n            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,\r\n            track_gain: ReplayGain.get(buf, 6),\r\n            album_gain: ReplayGain.get(buf, 8),\r\n            music_length: Token.UINT32_BE.get(buf, off + 20),\r\n            music_crc: Token.UINT8.get(buf, off + 24),\r\n            header_crc: Token.UINT16_BE.get(buf, off + 24)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=ExtendedLameHeader.js.map", "import * as Token from 'token-types';\r\nimport * as util from '../common/Util.js';\r\nimport { ExtendedLameHeader } from './ExtendedLameHeader.js';\r\n/**\r\n * Info Tag: Xing, LAME\r\n */\r\nexport const InfoTagHeaderTag = new Token.StringType(4, 'ascii');\r\n/**\r\n * LAME TAG value\r\n * Did not find any official documentation for this\r\n * Value e.g.: \"3.98.4\"\r\n */\r\nexport const LameEncoderVersion = new Token.StringType(6, 'ascii');\r\n/**\r\n * Info Tag\r\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n */\r\nexport const XingHeaderFlags = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            frames: util.isBitSet(buf, off, 31),\r\n            bytes: util.isBitSet(buf, off, 30),\r\n            toc: util.isBitSet(buf, off, 29),\r\n            vbrScale: util.isBitSet(buf, off, 28)\r\n        };\r\n    }\r\n};\r\n// /**\r\n//  * XING Header Tag\r\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n//  */\r\nexport async function readXingHeader(tokenizer) {\r\n    const flags = await tokenizer.readToken(XingHeaderFlags);\r\n    const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };\r\n    if (flags.frames) {\r\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    if (flags.bytes) {\r\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    if (flags.toc) {\r\n        xingInfoTag.toc = new Uint8Array(100);\r\n        await tokenizer.readBuffer(xingInfoTag.toc);\r\n    }\r\n    if (flags.vbrScale) {\r\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\r\n    if (lameTag === 'LAME') {\r\n        await tokenizer.ignore(4);\r\n        xingInfoTag.lame = {\r\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\r\n        };\r\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\r\n        if (match !== null) {\r\n            const majorMinorVersion = match[0]; // e.g. 3.97\r\n            const version = majorMinorVersion.split('.').map(n => Number.parseInt(n, 10));\r\n            if (version[0] >= 3 && version[1] >= 90) {\r\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);\r\n            }\r\n        }\r\n    }\r\n    return xingInfoTag;\r\n}\r\n//# sourceMappingURL=XingTag.js.map"],
  "mappings": "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",
  "names": ["NameCode", "ReplayGainOriginator", "initDebug"]
}
