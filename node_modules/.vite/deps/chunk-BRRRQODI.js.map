{
  "version": 3,
  "sources": ["../../peek-readable/lib/Errors.js", "../../peek-readable/lib/AbstractStreamReader.js", "../../peek-readable/lib/WebStreamReader.js", "../../peek-readable/lib/WebStreamByobReader.js", "../../peek-readable/lib/WebStreamDefaultReader.js", "../../peek-readable/lib/WebStreamReaderFactory.js", "../../strtok3/lib/AbstractTokenizer.js", "../../strtok3/lib/ReadStreamTokenizer.js", "../../strtok3/lib/BufferTokenizer.js", "../../strtok3/lib/core.js"],
  "sourcesContent": ["export const defaultMessages = 'End-Of-Stream';\r\n/**\r\n * Thrown on read operation of the end of file or stream has been reached\r\n */\r\nexport class EndOfStreamError extends Error {\r\n    constructor() {\r\n        super(defaultMessages);\r\n        this.name = \"EndOfStreamError\";\r\n    }\r\n}\r\nexport class AbortError extends Error {\r\n    constructor(message = \"The operation was aborted\") {\r\n        super(message);\r\n        this.name = \"AbortError\";\r\n    }\r\n}\r\n", "import { EndOfStreamError, AbortError } from \"./Errors.js\";\r\nexport class AbstractStreamReader {\r\n    constructor() {\r\n        this.endOfStream = false;\r\n        this.interrupted = false;\r\n        /**\r\n         * Store peeked data\r\n         * @type {Array}\r\n         */\r\n        this.peekQueue = [];\r\n    }\r\n    async peek(uint8Array, mayBeLess = false) {\r\n        const bytesRead = await this.read(uint8Array, mayBeLess);\r\n        this.peekQueue.push(uint8Array.subarray(0, bytesRead)); // Put read data back to peek buffer\r\n        return bytesRead;\r\n    }\r\n    async read(buffer, mayBeLess = false) {\r\n        if (buffer.length === 0) {\r\n            return 0;\r\n        }\r\n        let bytesRead = this.readFromPeekBuffer(buffer);\r\n        if (!this.endOfStream) {\r\n            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);\r\n        }\r\n        if (bytesRead === 0) {\r\n            throw new EndOfStreamError();\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @returns Number of bytes read\r\n     */\r\n    readFromPeekBuffer(buffer) {\r\n        let remaining = buffer.length;\r\n        let bytesRead = 0;\r\n        // consume peeked data first\r\n        while (this.peekQueue.length > 0 && remaining > 0) {\r\n            const peekData = this.peekQueue.pop(); // Front of queue\r\n            if (!peekData)\r\n                throw new Error('peekData should be defined');\r\n            const lenCopy = Math.min(peekData.length, remaining);\r\n            buffer.set(peekData.subarray(0, lenCopy), bytesRead);\r\n            bytesRead += lenCopy;\r\n            remaining -= lenCopy;\r\n            if (lenCopy < peekData.length) {\r\n                // remainder back to queue\r\n                this.peekQueue.push(peekData.subarray(lenCopy));\r\n            }\r\n        }\r\n        return bytesRead;\r\n    }\r\n    async readRemainderFromStream(buffer, mayBeLess) {\r\n        let bytesRead = 0;\r\n        // Continue reading from stream if required\r\n        while (bytesRead < buffer.length && !this.endOfStream) {\r\n            if (this.interrupted) {\r\n                throw new AbortError();\r\n            }\r\n            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);\r\n            if (chunkLen === 0)\r\n                break;\r\n            bytesRead += chunkLen;\r\n        }\r\n        if (!mayBeLess && bytesRead < buffer.length) {\r\n            throw new EndOfStreamError();\r\n        }\r\n        return bytesRead;\r\n    }\r\n}\r\n", "import { AbstractStreamReader } from \"./AbstractStreamReader.js\";\r\nexport class WebStreamReader extends AbstractStreamReader {\r\n    constructor(reader) {\r\n        super();\r\n        this.reader = reader;\r\n    }\r\n    async abort() {\r\n        return this.close();\r\n    }\r\n    async close() {\r\n        this.reader.releaseLock();\r\n    }\r\n}\r\n", "import { WebStreamReader } from './WebStreamReader.js';\r\n/**\r\n * Read from a WebStream using a BYOB reader\r\n * Reference: https://nodejs.org/api/webstreams.html#class-readablestreambyobreader\r\n */\r\nexport class WebStreamByobReader extends WebStreamReader {\r\n    /**\r\n     * Read from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param mayBeLess - If true, may fill the buffer partially\r\n     * @protected Bytes read\r\n     */\r\n    async readFromStream(buffer, mayBeLess) {\r\n        if (buffer.length === 0)\r\n            return 0;\r\n        // @ts-ignore\r\n        const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });\r\n        if (result.done) {\r\n            this.endOfStream = result.done;\r\n        }\r\n        if (result.value) {\r\n            buffer.set(result.value);\r\n            return result.value.length;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n", "import { EndOfStreamError } from './Errors.js';\r\nimport { AbstractStreamReader } from \"./AbstractStreamReader.js\";\r\nexport class WebStreamDefaultReader extends AbstractStreamReader {\r\n    constructor(reader) {\r\n        super();\r\n        this.reader = reader;\r\n        this.buffer = null; // Internal buffer to store excess data\r\n    }\r\n    /**\r\n     * Copy chunk to target, and store the remainder in this.buffer\r\n     */\r\n    writeChunk(target, chunk) {\r\n        const written = Math.min(chunk.length, target.length);\r\n        target.set(chunk.subarray(0, written));\r\n        // Adjust the remainder of the buffer\r\n        if (written < chunk.length) {\r\n            this.buffer = chunk.subarray(written);\r\n        }\r\n        else {\r\n            this.buffer = null;\r\n        }\r\n        return written;\r\n    }\r\n    /**\r\n     * Read from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param mayBeLess - If true, may fill the buffer partially\r\n     * @protected Bytes read\r\n     */\r\n    async readFromStream(buffer, mayBeLess) {\r\n        if (buffer.length === 0)\r\n            return 0;\r\n        let totalBytesRead = 0;\r\n        // Serve from the internal buffer first\r\n        if (this.buffer) {\r\n            totalBytesRead += this.writeChunk(buffer, this.buffer);\r\n        }\r\n        // Continue reading from the stream if more data is needed\r\n        while (totalBytesRead < buffer.length && !this.endOfStream) {\r\n            const result = await this.reader.read();\r\n            if (result.done) {\r\n                this.endOfStream = true;\r\n                break;\r\n            }\r\n            if (result.value) {\r\n                totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);\r\n            }\r\n        }\r\n        if (totalBytesRead === 0 && this.endOfStream) {\r\n            throw new EndOfStreamError();\r\n        }\r\n        return totalBytesRead;\r\n    }\r\n    abort() {\r\n        this.interrupted = true;\r\n        return this.reader.cancel();\r\n    }\r\n    async close() {\r\n        await this.abort();\r\n        this.reader.releaseLock();\r\n    }\r\n}\r\n", "import { WebStreamByobReader } from './WebStreamByobReader.js';\r\nimport { WebStreamDefaultReader } from './WebStreamDefaultReader.js';\r\nexport function makeWebStreamReader(stream) {\r\n    try {\r\n        const reader = stream.getReader({ mode: \"byob\" });\r\n        if (reader instanceof ReadableStreamDefaultReader) {\r\n            // Fallback to default reader in case `mode: byob` is ignored\r\n            return new WebStreamDefaultReader(reader);\r\n        }\r\n        return new WebStreamByobReader(reader);\r\n    }\r\n    catch (error) {\r\n        if (error instanceof TypeError) {\r\n            // Fallback to default reader in case `mode: byob` rejected by a `TypeError`\r\n            return new WebStreamDefaultReader(stream.getReader());\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n", "import { EndOfStreamError } from 'peek-readable';\r\n/**\r\n * Core tokenizer\r\n */\r\nexport class AbstractTokenizer {\r\n    /**\r\n     * Constructor\r\n     * @param options Tokenizer options\r\n     * @protected\r\n     */\r\n    constructor(options) {\r\n        this.numBuffer = new Uint8Array(8);\r\n        /**\r\n         * Tokenizer-stream position\r\n         */\r\n        this.position = 0;\r\n        this.onClose = options?.onClose;\r\n        if (options?.abortSignal) {\r\n            options.abortSignal.addEventListener('abort', () => {\r\n                this.abort();\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Read a token from the tokenizer-stream\r\n     * @param token - The token to read\r\n     * @param position - If provided, the desired position in the tokenizer-stream\r\n     * @returns Promise with token data\r\n     */\r\n    async readToken(token, position = this.position) {\r\n        const uint8Array = new Uint8Array(token.len);\r\n        const len = await this.readBuffer(uint8Array, { position });\r\n        if (len < token.len)\r\n            throw new EndOfStreamError();\r\n        return token.get(uint8Array, 0);\r\n    }\r\n    /**\r\n     * Peek a token from the tokenizer-stream.\r\n     * @param token - Token to peek from the tokenizer-stream.\r\n     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.\r\n     * @returns Promise with token data\r\n     */\r\n    async peekToken(token, position = this.position) {\r\n        const uint8Array = new Uint8Array(token.len);\r\n        const len = await this.peekBuffer(uint8Array, { position });\r\n        if (len < token.len)\r\n            throw new EndOfStreamError();\r\n        return token.get(uint8Array, 0);\r\n    }\r\n    /**\r\n     * Read a numeric token from the stream\r\n     * @param token - Numeric token\r\n     * @returns Promise with number\r\n     */\r\n    async readNumber(token) {\r\n        const len = await this.readBuffer(this.numBuffer, { length: token.len });\r\n        if (len < token.len)\r\n            throw new EndOfStreamError();\r\n        return token.get(this.numBuffer, 0);\r\n    }\r\n    /**\r\n     * Read a numeric token from the stream\r\n     * @param token - Numeric token\r\n     * @returns Promise with number\r\n     */\r\n    async peekNumber(token) {\r\n        const len = await this.peekBuffer(this.numBuffer, { length: token.len });\r\n        if (len < token.len)\r\n            throw new EndOfStreamError();\r\n        return token.get(this.numBuffer, 0);\r\n    }\r\n    /**\r\n     * Ignore number of bytes, advances the pointer in under tokenizer-stream.\r\n     * @param length - Number of bytes to ignore\r\n     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available\r\n     */\r\n    async ignore(length) {\r\n        if (this.fileInfo.size !== undefined) {\r\n            const bytesLeft = this.fileInfo.size - this.position;\r\n            if (length > bytesLeft) {\r\n                this.position += bytesLeft;\r\n                return bytesLeft;\r\n            }\r\n        }\r\n        this.position += length;\r\n        return length;\r\n    }\r\n    async close() {\r\n        await this.abort();\r\n        await this.onClose?.();\r\n    }\r\n    normalizeOptions(uint8Array, options) {\r\n        if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {\r\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n        }\r\n        return {\r\n            ...{\r\n                mayBeLess: false,\r\n                offset: 0,\r\n                length: uint8Array.length,\r\n                position: this.position\r\n            }, ...options\r\n        };\r\n    }\r\n    abort() {\r\n        return Promise.resolve(); // Ignore abort signal\r\n    }\r\n}\r\n", "import { AbstractTokenizer } from './AbstractTokenizer.js';\r\nimport { EndOfStreamError } from 'peek-readable';\r\nconst maxBufferSize = 256000;\r\nexport class ReadStreamTokenizer extends AbstractTokenizer {\r\n    /**\r\n     * Constructor\r\n     * @param streamReader stream-reader to read from\r\n     * @param options Tokenizer options\r\n     */\r\n    constructor(streamReader, options) {\r\n        super(options);\r\n        this.streamReader = streamReader;\r\n        this.fileInfo = options?.fileInfo ?? {};\r\n    }\r\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes read\r\n     */\r\n    async readBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        const skipBytes = normOptions.position - this.position;\r\n        if (skipBytes > 0) {\r\n            await this.ignore(skipBytes);\r\n            return this.readBuffer(uint8Array, options);\r\n        }\r\n        if (skipBytes < 0) {\r\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n        }\r\n        if (normOptions.length === 0) {\r\n            return 0;\r\n        }\r\n        const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);\r\n        this.position += bytesRead;\r\n        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\r\n            throw new EndOfStreamError();\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes peeked\r\n     */\r\n    async peekBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        let bytesRead = 0;\r\n        if (normOptions.position) {\r\n            const skipBytes = normOptions.position - this.position;\r\n            if (skipBytes > 0) {\r\n                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\r\n                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });\r\n                uint8Array.set(skipBuffer.subarray(skipBytes));\r\n                return bytesRead - skipBytes;\r\n            }\r\n            if (skipBytes < 0) {\r\n                throw new Error('Cannot peek from a negative offset in a stream');\r\n            }\r\n        }\r\n        if (normOptions.length > 0) {\r\n            try {\r\n                bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);\r\n            }\r\n            catch (err) {\r\n                if (options?.mayBeLess && err instanceof EndOfStreamError) {\r\n                    return 0;\r\n                }\r\n                throw err;\r\n            }\r\n            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {\r\n                throw new EndOfStreamError();\r\n            }\r\n        }\r\n        return bytesRead;\r\n    }\r\n    async ignore(length) {\r\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\r\n        const bufSize = Math.min(maxBufferSize, length);\r\n        const buf = new Uint8Array(bufSize);\r\n        let totBytesRead = 0;\r\n        while (totBytesRead < length) {\r\n            const remaining = length - totBytesRead;\r\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\r\n            if (bytesRead < 0) {\r\n                return bytesRead;\r\n            }\r\n            totBytesRead += bytesRead;\r\n        }\r\n        return totBytesRead;\r\n    }\r\n    abort() {\r\n        return this.streamReader.abort();\r\n    }\r\n    async close() {\r\n        return this.streamReader.close();\r\n    }\r\n    supportsRandomAccess() {\r\n        return false;\r\n    }\r\n}\r\n", "import { EndOfStreamError } from 'peek-readable';\r\nimport { AbstractTokenizer } from './AbstractTokenizer.js';\r\nexport class BufferTokenizer extends AbstractTokenizer {\r\n    /**\r\n     * Construct BufferTokenizer\r\n     * @param uint8Array - Uint8Array to tokenize\r\n     * @param options Tokenizer options\r\n     */\r\n    constructor(uint8Array, options) {\r\n        super(options);\r\n        this.uint8Array = uint8Array;\r\n        this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };\r\n    }\r\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Uint8Array to tokenize\r\n     * @param options - Read behaviour options\r\n     * @returns {Promise<number>}\r\n     */\r\n    async readBuffer(uint8Array, options) {\r\n        if (options?.position) {\r\n            this.position = options.position;\r\n        }\r\n        const bytesRead = await this.peekBuffer(uint8Array, options);\r\n        this.position += bytesRead;\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array\r\n     * @param options - Read behaviour options\r\n     * @returns {Promise<number>}\r\n     */\r\n    async peekBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);\r\n        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {\r\n            throw new EndOfStreamError();\r\n        }\r\n        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));\r\n        return bytes2read;\r\n    }\r\n    close() {\r\n        return super.close();\r\n    }\r\n    supportsRandomAccess() {\r\n        return true;\r\n    }\r\n    setPosition(position) {\r\n        this.position = position;\r\n    }\r\n}\r\n", "import { StreamReader, makeWebStreamReader } from 'peek-readable';\r\nimport { ReadStreamTokenizer } from './ReadStreamTokenizer.js';\r\nimport { BufferTokenizer } from './BufferTokenizer.js';\r\nexport { EndOfStreamError, AbortError } from 'peek-readable';\r\nexport { AbstractTokenizer } from './AbstractTokenizer.js';\r\n/**\r\n * Construct ReadStreamTokenizer from given Stream.\r\n * Will set fileSize, if provided given Stream has set the .path property/\r\n * @param stream - Read from Node.js Stream.Readable\r\n * @param options - Tokenizer options\r\n * @returns ReadStreamTokenizer\r\n */\r\nexport function fromStream(stream, options) {\r\n    const streamReader = new StreamReader(stream);\r\n    const _options = options ?? {};\r\n    const chainedClose = _options.onClose;\r\n    _options.onClose = async () => {\r\n        await streamReader.close();\r\n        if (chainedClose) {\r\n            return chainedClose();\r\n        }\r\n    };\r\n    return new ReadStreamTokenizer(streamReader, _options);\r\n}\r\n/**\r\n * Construct ReadStreamTokenizer from given ReadableStream (WebStream API).\r\n * Will set fileSize, if provided given Stream has set the .path property/\r\n * @param webStream - Read from Node.js Stream.Readable (must be a byte stream)\r\n * @param options - Tokenizer options\r\n * @returns ReadStreamTokenizer\r\n */\r\nexport function fromWebStream(webStream, options) {\r\n    const webStreamReader = makeWebStreamReader(webStream);\r\n    const _options = options ?? {};\r\n    const chainedClose = _options.onClose;\r\n    _options.onClose = async () => {\r\n        await webStreamReader.close();\r\n        if (chainedClose) {\r\n            return chainedClose();\r\n        }\r\n    };\r\n    return new ReadStreamTokenizer(webStreamReader, _options);\r\n}\r\n/**\r\n * Construct ReadStreamTokenizer from given Buffer.\r\n * @param uint8Array - Uint8Array to tokenize\r\n * @param options - Tokenizer options\r\n * @returns BufferTokenizer\r\n */\r\nexport function fromBuffer(uint8Array, options) {\r\n    return new BufferTokenizer(uint8Array, options);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
