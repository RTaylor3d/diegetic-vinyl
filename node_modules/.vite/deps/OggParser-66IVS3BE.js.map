{
  "version": 3,
  "sources": ["../../music-metadata/lib/ogg/OggParser.js", "../../music-metadata/lib/ogg/opus/Opus.js", "../../music-metadata/lib/ogg/opus/OpusParser.js", "../../music-metadata/lib/ogg/speex/SpeexParser.js", "../../music-metadata/lib/ogg/speex/Speex.js", "../../music-metadata/lib/ogg/theora/TheoraParser.js", "../../music-metadata/lib/ogg/theora/Theora.js"],
  "sourcesContent": ["import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport * as util from '../common/Util.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { VorbisParser } from './vorbis/VorbisParser.js';\nimport { OpusParser } from './opus/OpusParser.js';\nimport { SpeexParser } from './speex/SpeexParser.js';\nimport { TheoraParser } from './theora/TheoraParser.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\n}\nconst debug = initDebug('music-metadata:parser:ogg');\nexport class SegmentTable {\n    static sum(buf, off, len) {\n        const dv = new DataView(buf.buffer, 0);\n        let s = 0;\n        for (let i = off; i < off + len; ++i) {\n            s += dv.getUint8(i);\n        }\n        return s;\n    }\n    constructor(header) {\n        this.len = header.page_segments;\n    }\n    get(buf, off) {\n        return {\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\n        };\n    }\n}\n/**\n * Parser for Ogg logical bitstream framing\n */\nexport class OggParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.header = null;\n        this.pageNumber = 0;\n        this.pageConsumer = null;\n    }\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        debug('pos=%s, parsePage()', this.tokenizer.position);\n        try {\n            let header;\n            do {\n                header = await this.tokenizer.readToken(OggParser.Header);\n                if (header.capturePattern !== 'OggS')\n                    throw new OggContentError('Invalid Ogg capture pattern');\n                this.metadata.setFormat('container', 'Ogg');\n                this.header = header;\n                this.pageNumber = header.pageSequenceNo;\n                debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);\n                const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));\n                debug('totalPageSize=%s', segmentTable.totalPageSize);\n                const pageData = await this.tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n                debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n                if (header.headerType.firstPage) {\n                    const id = new TextDecoder('ascii').decode(pageData.subarray(0, 7));\n                    switch (id) {\n                        case '\\x01vorbis': // Ogg/Vorbis\n                            debug('Set page consumer to Ogg/Vorbis');\n                            this.pageConsumer = new VorbisParser(this.metadata, this.options);\n                            break;\n                        case 'OpusHea': // Ogg/Opus\n                            debug('Set page consumer to Ogg/Opus');\n                            this.pageConsumer = new OpusParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'Speex  ': // Ogg/Speex\n                            debug('Set page consumer to Ogg/Speex');\n                            this.pageConsumer = new SpeexParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'fishead':\n                        case '\\x00theora': // Ogg/Theora\n                            debug('Set page consumer to Ogg/Theora');\n                            this.pageConsumer = new TheoraParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        default:\n                            throw new OggContentError(`gg audio-codec not recognized (id=${id})`);\n                    }\n                }\n                await this.pageConsumer.parsePage(header, pageData);\n            } while (!header.headerType.lastPage);\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                if (err instanceof EndOfStreamError) {\n                    this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                    debug(\"End-of-stream\");\n                    this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                    if (this.header) {\n                        this.pageConsumer.calculateDuration(this.header);\n                    }\n                }\n                else if (err.message.startsWith('FourCC')) {\n                    if (this.pageNumber > 0) {\n                        // ignore this error: work-around if last OGG-page is not marked with last-page flag\n                        this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');\n                        await this.pageConsumer.flush();\n                    }\n                }\n            }\n            else\n                throw err;\n        }\n    }\n}\nOggParser.Header = {\n    len: 27,\n    get: (buf, off) => {\n        return {\n            capturePattern: FourCcToken.get(buf, off),\n            version: Token.UINT8.get(buf, off + 4),\n            headerType: {\n                continued: util.getBit(buf, off + 5, 0),\n                firstPage: util.getBit(buf, off + 5, 1),\n                lastPage: util.getBit(buf, off + 5, 2)\n            },\n            // packet_flag: Token.UINT8.get(buf, off + 5),\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n            page_segments: Token.UINT8.get(buf, off + 26)\n        };\n    }\n};\n//# sourceMappingURL=OggParser.js.map", "import * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nexport class OpusContentError extends makeUnexpectedFileContentError('Opus') {\n}\n/**\n * Opus ID Header parser\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\n */\nexport class IdHeader {\n    constructor(len) {\n        this.len = len;\n        if (len < 19) {\n            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');\n        }\n    }\n    get(buf, off) {\n        return {\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: Token.UINT8.get(buf, off + 8),\n            channelCount: Token.UINT8.get(buf, off + 9),\n            preSkip: Token.UINT16_LE.get(buf, off + 10),\n            inputSampleRate: Token.UINT32_LE.get(buf, off + 12),\n            outputGain: Token.UINT16_LE.get(buf, off + 16),\n            channelMapping: Token.UINT8.get(buf, off + 18)\n        };\n    }\n}\n//# sourceMappingURL=Opus.js.map", "import * as Token from 'token-types';\nimport { VorbisParser } from '../vorbis/VorbisParser.js';\nimport * as Opus from './Opus.js';\nimport { OpusContentError } from './Opus.js';\n/**\n * Opus parser\n * Internet Engineering Task Force (IETF) - RFC 6716\n * Used by OggParser\n */\nexport class OpusParser extends VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n        this.idHeader = null;\n        this.lastPos = -1;\n    }\n    /**\n     * Parse first Opus Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Opus');\n        // Parse Opus ID Header\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\n        if (this.idHeader.magicSignature !== \"OpusHead\")\n            throw new OpusContentError(\"Illegal ogg/Opus magic-signature\");\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\n    }\n    async parseFullPage(pageData) {\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\n        switch (magicSignature) {\n            case 'OpusTags':\n                await this.parseUserCommentList(pageData, 8);\n                this.lastPos = this.tokenizer.position - pageData.length;\n                break;\n            default:\n                break;\n        }\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\n            this.metadata.setFormat('duration', pos_48bit / 48000);\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n            }\n        }\n    }\n}\n//# sourceMappingURL=OpusParser.js.map", "import initDebug from 'debug';\nimport { VorbisParser } from '../vorbis/VorbisParser.js';\nimport * as Speex from './Speex.js';\nconst debug = initDebug('music-metadata:parser:ogg:speex');\n/**\n * Speex, RFC 5574\n * Ref:\n * - https://www.speex.org/docs/manual/speex-manual/\n * - https://tools.ietf.org/html/rfc5574\n */\nexport class SpeexParser extends VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Speex Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(header, pageData) {\n        debug('First Ogg/Speex page');\n        const speexHeader = Speex.Header.get(pageData, 0);\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\n        if (speexHeader.bitrate !== -1) {\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\n        }\n    }\n}\n//# sourceMappingURL=SpeexParser.js.map", "import * as Token from 'token-types';\nimport * as util from '../../common/Util.js';\n/**\n * Speex Header Packet\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\n */\nexport const Header = {\n    len: 80,\n    get: (buf, off) => {\n        return {\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\n            version_id: Token.INT32_LE.get(buf, off + 28),\n            header_size: Token.INT32_LE.get(buf, off + 32),\n            rate: Token.INT32_LE.get(buf, off + 36),\n            mode: Token.INT32_LE.get(buf, off + 40),\n            mode_bitstream_version: Token.INT32_LE.get(buf, off + 44),\n            nb_channels: Token.INT32_LE.get(buf, off + 48),\n            bitrate: Token.INT32_LE.get(buf, off + 52),\n            frame_size: Token.INT32_LE.get(buf, off + 56),\n            vbr: Token.INT32_LE.get(buf, off + 60),\n            frames_per_packet: Token.INT32_LE.get(buf, off + 64),\n            extra_headers: Token.INT32_LE.get(buf, off + 68),\n            reserved1: Token.INT32_LE.get(buf, off + 72),\n            reserved2: Token.INT32_LE.get(buf, off + 76)\n        };\n    }\n};\n//# sourceMappingURL=Speex.js.map", "import initDebug from 'debug';\nimport { IdentificationHeader } from './Theora.js';\nconst debug = initDebug('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n * - https://theora.org/doc/Theora.pdf\n */\nexport class TheoraParser {\n    constructor(metadata, options, tokenizer) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            await this.parseFirstPage(header, pageData);\n        }\n    }\n    async flush() {\n        debug('flush');\n    }\n    calculateDuration(header) {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    async parseFirstPage(header, pageData) {\n        debug('First Ogg/Theora page');\n        this.metadata.setFormat('codec', 'Theora');\n        const idHeader = IdentificationHeader.get(pageData, 0);\n        this.metadata.setFormat('bitrate', idHeader.nombr);\n    }\n}\n//# sourceMappingURL=TheoraParser.js.map", "import * as Token from 'token-types';\n/**\n * 6.2 Identification Header\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\n */\nexport const IdentificationHeader = {\n    len: 42,\n    get: (buf, off) => {\n        return {\n            id: new Token.StringType(7, 'ascii').get(buf, off),\n            vmaj: Token.UINT8.get(buf, off + 7),\n            vmin: Token.UINT8.get(buf, off + 8),\n            vrev: Token.UINT8.get(buf, off + 9),\n            vmbw: Token.UINT16_BE.get(buf, off + 10),\n            vmbh: Token.UINT16_BE.get(buf, off + 17),\n            nombr: Token.UINT24_BE.get(buf, off + 37),\n            nqual: Token.UINT8.get(buf, off + 40)\n        };\n    }\n};\n//# sourceMappingURL=Theora.js.map"],
  "mappings": "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",
  "names": ["import_debug", "initDebug", "import_debug", "debug", "initDebug", "debug", "initDebug"]
}
