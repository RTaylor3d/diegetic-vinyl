{
  "version": 3,
  "sources": ["../../music-metadata/lib/aiff/AiffParser.js", "../../music-metadata/lib/aiff/AiffToken.js", "../../music-metadata/lib/iff/index.js"],
  "sourcesContent": ["import * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as strtok3 from 'strtok3';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport * as AiffToken from './AiffToken.js';\r\nimport { AiffContentError, compressionTypes } from './AiffToken.js';\r\nimport * as iff from '../iff/index.js';\r\nconst debug = initDebug('music-metadata:parser:aiff');\r\n/**\r\n * AIFF - Audio Interchange File Format\r\n *\r\n * Ref:\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\r\n */\r\nexport class AIFFParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.isCompressed = null;\r\n    }\r\n    async parse() {\r\n        const header = await this.tokenizer.readToken(iff.Header);\r\n        if (header.chunkID !== 'FORM')\r\n            throw new AiffContentError('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\r\n        const type = await this.tokenizer.readToken(FourCcToken);\r\n        switch (type) {\r\n            case 'AIFF':\r\n                this.metadata.setFormat('container', type);\r\n                this.isCompressed = false;\r\n                break;\r\n            case 'AIFC':\r\n                this.metadata.setFormat('container', 'AIFF-C');\r\n                this.isCompressed = true;\r\n                break;\r\n            default:\r\n                throw new AiffContentError(`Unsupported AIFF type: ${type}`);\r\n        }\r\n        this.metadata.setFormat('lossless', !this.isCompressed);\r\n        try {\r\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\r\n                debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);\r\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\r\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\r\n                const bytesRead = await this.readData(chunkHeader);\r\n                await this.tokenizer.ignore(nextChunk - bytesRead);\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof strtok3.EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    async readData(header) {\r\n        switch (header.chunkID) {\r\n            case 'COMM': { // The Common Chunk\r\n                if (this.isCompressed === null) {\r\n                    throw new AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');\r\n                }\r\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\r\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\r\n                this.metadata.setFormat('sampleRate', common.sampleRate);\r\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\r\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\r\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\r\n                if (common.compressionName || common.compressionType) {\r\n                    this.metadata.setFormat('codec', common.compressionName ?? compressionTypes[common.compressionType]);\r\n                }\r\n                return header.chunkSize;\r\n            }\r\n            case 'ID3 ': { // ID3-meta-data\r\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\r\n                const rst = strtok3.fromBuffer(id3_data);\r\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                return header.chunkSize;\r\n            }\r\n            case 'SSND': // Sound Data Chunk\r\n                if (this.metadata.format.duration) {\r\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\r\n                }\r\n                return 0;\r\n            case 'NAME': // Sample name chunk\r\n            case 'AUTH': // Author chunk\r\n            case '(c) ': // Copyright chunk\r\n            case 'ANNO': // Annotation chunk\r\n                return this.readTextChunk(header);\r\n            default:\r\n                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\r\n                return 0;\r\n        }\r\n    }\r\n    async readTextChunk(header) {\r\n        const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\r\n        const values = value.split('\\0').map(v => v.trim()).filter(v => v?.length);\r\n        await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));\r\n        return header.chunkSize;\r\n    }\r\n}\r\n//# sourceMappingURL=AiffParser.js.map", "import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nexport const compressionTypes = {\r\n    NONE: 'not compressed\tPCM\tApple Computer',\r\n    sowt: 'PCM (byte swapped)',\r\n    fl32: '32-bit floating point IEEE 32-bit float',\r\n    fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\r\n    alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\r\n    ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\r\n    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\r\n    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\r\n    FL32: 'Float 32\tIEEE 32-bit float '\r\n};\r\nexport class AiffContentError extends makeUnexpectedFileContentError('AIFF') {\r\n}\r\nexport class Common {\r\n    constructor(header, isAifc) {\r\n        this.isAifc = isAifc;\r\n        const minimumChunkSize = isAifc ? 22 : 18;\r\n        if (header.chunkSize < minimumChunkSize)\r\n            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);\r\n        this.len = header.chunkSize;\r\n    }\r\n    get(buf, off) {\r\n        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value\r\n        const shift = Token.UINT16_BE.get(buf, off + 8) - 16398;\r\n        const baseSampleRate = Token.UINT16_BE.get(buf, off + 8 + 2);\r\n        const res = {\r\n            numChannels: Token.UINT16_BE.get(buf, off),\r\n            numSampleFrames: Token.UINT32_BE.get(buf, off + 2),\r\n            sampleSize: Token.UINT16_BE.get(buf, off + 6),\r\n            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift\r\n        };\r\n        if (this.isAifc) {\r\n            res.compressionType = FourCcToken.get(buf, off + 18);\r\n            if (this.len > 22) {\r\n                const strLen = Token.UINT8.get(buf, off + 22);\r\n                if (strLen > 0) {\r\n                    const padding = (strLen + 1) % 2;\r\n                    if (23 + strLen + padding === this.len) {\r\n                        res.compressionName = new Token.StringType(strLen, 'latin1').get(buf, off + 23);\r\n                    }\r\n                    else {\r\n                        throw new AiffContentError('Illegal pstring length');\r\n                    }\r\n                }\r\n                else {\r\n                    res.compressionName = undefined;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res.compressionName = 'PCM';\r\n        }\r\n        return res;\r\n    }\r\n}\r\n//# sourceMappingURL=AiffToken.js.map", "import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\n/**\r\n * Common AIFF chunk header\r\n */\r\nexport const Header = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Chunk type ID\r\n            chunkID: FourCcToken.get(buf, off),\r\n            // Chunk size\r\n            chunkSize: Number(BigInt(Token.UINT32_BE.get(buf, off + 4)))\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=index.js.map"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,mBAAsB;;;ACEf,IAAM,mBAAmB;AAAA,EAC5B,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AACV;AACO,IAAM,mBAAN,cAA+B,+BAA+B,MAAM,EAAE;AAC7E;AACO,IAAM,SAAN,MAAa;AAAA,EAChB,YAAY,QAAQ,QAAQ;AACxB,SAAK,SAAS;AACd,UAAM,mBAAmB,SAAS,KAAK;AACvC,QAAI,OAAO,YAAY;AACnB,YAAM,IAAI,iBAAiB,+CAA+C,gBAAgB,EAAE;AAChG,SAAK,MAAM,OAAO;AAAA,EACtB;AAAA,EACA,IAAI,KAAK,KAAK;AAEV,UAAM,QAAc,UAAU,IAAI,KAAK,MAAM,CAAC,IAAI;AAClD,UAAM,iBAAuB,UAAU,IAAI,KAAK,MAAM,IAAI,CAAC;AAC3D,UAAM,MAAM;AAAA,MACR,aAAmB,UAAU,IAAI,KAAK,GAAG;AAAA,MACzC,iBAAuB,UAAU,IAAI,KAAK,MAAM,CAAC;AAAA,MACjD,YAAkB,UAAU,IAAI,KAAK,MAAM,CAAC;AAAA,MAC5C,YAAY,QAAQ,IAAI,kBAAkB,KAAK,IAAI,KAAK,IAAI,kBAAkB;AAAA,IAClF;AACA,QAAI,KAAK,QAAQ;AACb,UAAI,kBAAkB,YAAY,IAAI,KAAK,MAAM,EAAE;AACnD,UAAI,KAAK,MAAM,IAAI;AACf,cAAM,SAAe,MAAM,IAAI,KAAK,MAAM,EAAE;AAC5C,YAAI,SAAS,GAAG;AACZ,gBAAM,WAAW,SAAS,KAAK;AAC/B,cAAI,KAAK,SAAS,YAAY,KAAK,KAAK;AACpC,gBAAI,kBAAkB,IAAU,WAAW,QAAQ,QAAQ,EAAE,IAAI,KAAK,MAAM,EAAE;AAAA,UAClF,OACK;AACD,kBAAM,IAAI,iBAAiB,wBAAwB;AAAA,UACvD;AAAA,QACJ,OACK;AACD,cAAI,kBAAkB;AAAA,QAC1B;AAAA,MACJ;AAAA,IACJ,OACK;AACD,UAAI,kBAAkB;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AACJ;;;ACpDO,IAAM,SAAS;AAAA,EAClB,KAAK;AAAA,EACL,KAAK,CAAC,KAAK,QAAQ;AACf,WAAO;AAAA;AAAA,MAEH,SAAS,YAAY,IAAI,KAAK,GAAG;AAAA;AAAA,MAEjC,WAAW,OAAO,OAAa,UAAU,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;AAAA,IAC/D;AAAA,EACJ;AACJ;;;AFNA,IAAM,YAAQ,aAAAA,SAAU,4BAA4B;AAQ7C,IAAM,aAAN,cAAyB,YAAY;AAAA,EACxC,cAAc;AACV,UAAM,GAAG,SAAS;AAClB,SAAK,eAAe;AAAA,EACxB;AAAA,EACA,MAAM,QAAQ;AACV,UAAM,SAAS,MAAM,KAAK,UAAU,UAAc,MAAM;AACxD,QAAI,OAAO,YAAY;AACnB,YAAM,IAAI,iBAAiB,mCAAqC;AACpE,UAAM,OAAO,MAAM,KAAK,UAAU,UAAU,WAAW;AACvD,YAAQ,MAAM;AAAA,MACV,KAAK;AACD,aAAK,SAAS,UAAU,aAAa,IAAI;AACzC,aAAK,eAAe;AACpB;AAAA,MACJ,KAAK;AACD,aAAK,SAAS,UAAU,aAAa,QAAQ;AAC7C,aAAK,eAAe;AACpB;AAAA,MACJ;AACI,cAAM,IAAI,iBAAiB,0BAA0B,IAAI,EAAE;AAAA,IACnE;AACA,SAAK,SAAS,UAAU,YAAY,CAAC,KAAK,YAAY;AACtD,QAAI;AACA,aAAO,CAAC,KAAK,UAAU,SAAS,QAAQ,KAAK,UAAU,SAAS,OAAO,KAAK,UAAU,YAAgB,OAAO,KAAK;AAC9G,cAAM,gCAAgC,KAAK,UAAU,QAAQ,EAAE;AAC/D,cAAM,cAAc,MAAM,KAAK,UAAU,UAAc,MAAM;AAC7D,cAAM,YAAY,IAAI,KAAK,MAAM,YAAY,YAAY,CAAC;AAC1D,cAAM,YAAY,MAAM,KAAK,SAAS,WAAW;AACjD,cAAM,KAAK,UAAU,OAAO,YAAY,SAAS;AAAA,MACrD;AAAA,IACJ,SACO,KAAK;AACR,UAAI,eAAuB,kBAAkB;AACzC,cAAM,eAAe;AAAA,MACzB,OACK;AACD,cAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,MAAM,SAAS,QAAQ;AACnB,YAAQ,OAAO,SAAS;AAAA,MACpB,KAAK,QAAQ;AACT,YAAI,KAAK,iBAAiB,MAAM;AAC5B,gBAAM,IAAI,iBAAiB,kEAAkE;AAAA,QACjG;AACA,cAAM,SAAS,MAAM,KAAK,UAAU,UAAU,IAAc,OAAO,QAAQ,KAAK,YAAY,CAAC;AAC7F,aAAK,SAAS,UAAU,iBAAiB,OAAO,UAAU;AAC1D,aAAK,SAAS,UAAU,cAAc,OAAO,UAAU;AACvD,aAAK,SAAS,UAAU,oBAAoB,OAAO,WAAW;AAC9D,aAAK,SAAS,UAAU,mBAAmB,OAAO,eAAe;AACjE,aAAK,SAAS,UAAU,YAAY,OAAO,kBAAkB,OAAO,UAAU;AAC9E,YAAI,OAAO,mBAAmB,OAAO,iBAAiB;AAClD,eAAK,SAAS,UAAU,SAAS,OAAO,mBAAmB,iBAAiB,OAAO,eAAe,CAAC;AAAA,QACvG;AACA,eAAO,OAAO;AAAA,MAClB;AAAA,MACA,KAAK,QAAQ;AACT,cAAM,WAAW,MAAM,KAAK,UAAU,UAAU,IAAU,eAAe,OAAO,SAAS,CAAC;AAC1F,cAAM,MAAc,WAAW,QAAQ;AACvC,cAAM,IAAI,YAAY,EAAE,MAAM,KAAK,UAAU,KAAK,KAAK,OAAO;AAC9D,eAAO,OAAO;AAAA,MAClB;AAAA,MACA,KAAK;AACD,YAAI,KAAK,SAAS,OAAO,UAAU;AAC/B,eAAK,SAAS,UAAU,WAAW,IAAI,OAAO,YAAY,KAAK,SAAS,OAAO,QAAQ;AAAA,QAC3F;AACA,eAAO;AAAA,MACX,KAAK;AAAA;AAAA,MACL,KAAK;AAAA;AAAA,MACL,KAAK;AAAA;AAAA,MACL,KAAK;AACD,eAAO,KAAK,cAAc,MAAM;AAAA,MACpC;AACI,cAAM,mBAAmB,OAAO,OAAO,UAAU,OAAO,SAAS,EAAE;AACnE,eAAO;AAAA,IACf;AAAA,EACJ;AAAA,EACA,MAAM,cAAc,QAAQ;AACxB,UAAM,QAAQ,MAAM,KAAK,UAAU,UAAU,IAAU,WAAW,OAAO,WAAW,OAAO,CAAC;AAC5F,UAAM,SAAS,MAAM,MAAM,IAAI,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAK,uBAAG,MAAM;AACzE,UAAM,QAAQ,IAAI,OAAO,IAAI,OAAK,KAAK,SAAS,OAAO,QAAQ,OAAO,SAAS,CAAC,CAAC,CAAC;AAClF,WAAO,OAAO;AAAA,EAClB;AACJ;",
  "names": ["initDebug"]
}
