{
  "version": 3,
  "sources": ["../../music-metadata/lib/apev2/APEv2Parser.js", "../../music-metadata/lib/apev2/APEv2Token.js"],
  "sourcesContent": ["import initDebug from 'debug';\r\nimport * as strtok3 from 'strtok3';\r\nimport { StringType } from 'token-types';\r\nimport { uint8ArrayToString } from 'uint8array-extras';\r\nimport * as util from '../common/Util.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { DataType, DescriptorParser, Header, TagFooter, TagItemHeader } from './APEv2Token.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:APEv2');\r\nconst tagFormat = 'APEv2';\r\nconst preamble = 'APETAGEX';\r\nexport class ApeContentError extends makeUnexpectedFileContentError('APEv2') {\r\n}\r\nexport class APEv2Parser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.ape = {};\r\n    }\r\n    static tryParseApeHeader(metadata, tokenizer, options) {\r\n        const apeParser = new APEv2Parser(metadata, tokenizer, options);\r\n        return apeParser.tryParseApeHeader();\r\n    }\r\n    /**\r\n     * Calculate the media file duration\r\n     * @param ah ApeHeader\r\n     * @return {number} duration in seconds\r\n     */\r\n    static calculateDuration(ah) {\r\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\r\n        duration += ah.finalFrameBlocks;\r\n        return duration / ah.sampleRate;\r\n    }\r\n    /**\r\n     * Calculates the APEv1 / APEv2 first field offset\r\n     * @param tokenizer\r\n     * @param offset\r\n     */\r\n    static async findApeFooterOffset(tokenizer, offset) {\r\n        // Search for APE footer header at the end of the file\r\n        const apeBuf = new Uint8Array(TagFooter.len);\r\n        const position = tokenizer.position;\r\n        await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });\r\n        tokenizer.setPosition(position);\r\n        const tagFooter = TagFooter.get(apeBuf, 0);\r\n        if (tagFooter.ID === 'APETAGEX') {\r\n            if (tagFooter.flags.isHeader) {\r\n                debug(`APE Header found at offset=${offset - TagFooter.len}`);\r\n            }\r\n            else {\r\n                debug(`APE Footer found at offset=${offset - TagFooter.len}`);\r\n                offset -= tagFooter.size;\r\n            }\r\n            return { footer: tagFooter, offset };\r\n        }\r\n    }\r\n    static parseTagFooter(metadata, buffer, options) {\r\n        const footer = TagFooter.get(buffer, buffer.length - TagFooter.len);\r\n        if (footer.ID !== preamble)\r\n            throw new ApeContentError('Unexpected APEv2 Footer ID preamble value');\r\n        strtok3.fromBuffer(buffer);\r\n        const apeParser = new APEv2Parser(metadata, strtok3.fromBuffer(buffer), options);\r\n        return apeParser.parseTags(footer);\r\n    }\r\n    /**\r\n     * Parse APEv1 / APEv2 header if header signature found\r\n     */\r\n    async tryParseApeHeader() {\r\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {\r\n            debug(\"No APEv2 header found, end-of-file reached\");\r\n            return;\r\n        }\r\n        const footer = await this.tokenizer.peekToken(TagFooter);\r\n        if (footer.ID === preamble) {\r\n            await this.tokenizer.ignore(TagFooter.len);\r\n            return this.parseTags(footer);\r\n        }\r\n        debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\r\n        if (this.tokenizer.fileInfo.size) {\r\n            // Try to read the APEv2 header using just the footer-header\r\n            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\r\n            const buffer = new Uint8Array(remaining);\r\n            await this.tokenizer.readBuffer(buffer);\r\n            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\r\n        }\r\n    }\r\n    async parse() {\r\n        const descriptor = await this.tokenizer.readToken(DescriptorParser);\r\n        if (descriptor.ID !== 'MAC ')\r\n            throw new ApeContentError('Unexpected descriptor ID');\r\n        this.ape.descriptor = descriptor;\r\n        const lenExp = descriptor.descriptorBytes - DescriptorParser.len;\r\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\r\n        await this.tokenizer.ignore(header.forwardBytes);\r\n        return this.tryParseApeHeader();\r\n    }\r\n    async parseTags(footer) {\r\n        const keyBuffer = new Uint8Array(256); // maximum tag key length\r\n        let bytesRemaining = footer.size - TagFooter.len;\r\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\r\n        for (let i = 0; i < footer.fields; i++) {\r\n            if (bytesRemaining < TagItemHeader.len) {\r\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\r\n                break;\r\n            }\r\n            // Only APEv2 tag has tag item headers\r\n            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);\r\n            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;\r\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\r\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\r\n            const key = await this.tokenizer.readToken(new StringType(zero, 'ascii'));\r\n            await this.tokenizer.ignore(1);\r\n            bytesRemaining -= key.length + 1;\r\n            switch (tagItemHeader.flags.dataType) {\r\n                case DataType.text_utf8: { // utf-8 text-string\r\n                    const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, 'utf8'));\r\n                    const values = value.split(/\\x00/g);\r\n                    await Promise.all(values.map(val => this.metadata.addTag(tagFormat, key, val)));\r\n                    break;\r\n                }\r\n                case DataType.binary: // binary (probably artwork)\r\n                    if (this.options.skipCovers) {\r\n                        await this.tokenizer.ignore(tagItemHeader.size);\r\n                    }\r\n                    else {\r\n                        const picData = new Uint8Array(tagItemHeader.size);\r\n                        await this.tokenizer.readBuffer(picData);\r\n                        zero = util.findZero(picData, 0, picData.length);\r\n                        const description = uint8ArrayToString(picData.slice(0, zero));\r\n                        const data = picData.slice(zero + 1);\r\n                        await this.metadata.addTag(tagFormat, key, {\r\n                            description,\r\n                            data\r\n                        });\r\n                    }\r\n                    break;\r\n                case DataType.external_info:\r\n                    debug(`Ignore external info ${key}`);\r\n                    await this.tokenizer.ignore(tagItemHeader.size);\r\n                    break;\r\n                case DataType.reserved:\r\n                    debug(`Ignore external info ${key}`);\r\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\r\n                    await this.tokenizer.ignore(tagItemHeader.size);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    async parseDescriptorExpansion(lenExp) {\r\n        await this.tokenizer.ignore(lenExp);\r\n        return this.parseHeader();\r\n    }\r\n    async parseHeader() {\r\n        const header = await this.tokenizer.readToken(Header);\r\n        // ToDo before\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\r\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\r\n        this.metadata.setFormat('sampleRate', header.sampleRate);\r\n        this.metadata.setFormat('numberOfChannels', header.channel);\r\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\r\n        if (!this.ape.descriptor) {\r\n            throw new ApeContentError('Missing APE descriptor');\r\n        }\r\n        return {\r\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\r\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=APEv2Parser.js.map", "import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nexport var DataType;\r\n(function (DataType) {\r\n    DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\r\n    DataType[DataType[\"binary\"] = 1] = \"binary\";\r\n    DataType[DataType[\"external_info\"] = 2] = \"external_info\";\r\n    DataType[DataType[\"reserved\"] = 3] = \"reserved\";\r\n})(DataType || (DataType = {}));\r\n/**\r\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n */\r\nexport const DescriptorParser = {\r\n    len: 52,\r\n    get: (buf, off) => {\r\n        return {\r\n            // should equal 'MAC '\r\n            ID: FourCcToken.get(buf, off),\r\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\r\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\r\n            // the number of descriptor bytes (allows later expansion of this header)\r\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\r\n            // the number of header APE_HEADER bytes\r\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\r\n            // the number of header APE_HEADER bytes\r\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\r\n            // the number of header data bytes (from original file)\r\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\r\n            // the number of bytes of APE frame data\r\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\r\n            // the high order number of APE frame data bytes\r\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\r\n            // the terminating data of the file (not including tag data)\r\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\r\n            // the MD5 hash of the file (see notes for usage... it's a little tricky)\r\n            fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE_HEADER: describes all of the necessary information about the APE file\r\n */\r\nexport const Header = {\r\n    len: 24,\r\n    get: (buf, off) => {\r\n        return {\r\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\r\n            compressionLevel: Token.UINT16_LE.get(buf, off),\r\n            // any format flags (for future use)\r\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\r\n            // the number of audio blocks in one frame\r\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\r\n            // the number of audio blocks in the final frame\r\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\r\n            // the total number of frames\r\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\r\n            // the bits per sample (typically 16)\r\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\r\n            // the number of channels (1 or 2)\r\n            channel: Token.UINT16_LE.get(buf, off + 18),\r\n            // the sample rate (typically 44100)\r\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE Tag Header/Footer Version 2.0\r\n * TAG: describes all the properties of the file [optional]\r\n */\r\nexport const TagFooter = {\r\n    len: 32,\r\n    get: (buf, off) => {\r\n        return {\r\n            // should equal 'APETAGEX'\r\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\r\n            // equals CURRENT_APE_TAG_VERSION\r\n            version: Token.UINT32_LE.get(buf, off + 8),\r\n            // the complete size of the tag, including this footer (excludes header)\r\n            size: Token.UINT32_LE.get(buf, off + 12),\r\n            // the number of fields in the tag\r\n            fields: Token.UINT32_LE.get(buf, off + 16),\r\n            // reserved for later use (must be zero),\r\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE Tag v2.0 Item Header\r\n */\r\nexport const TagItemHeader = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Length of assigned value in bytes\r\n            size: Token.UINT32_LE.get(buf, off),\r\n            // reserved for later use (must be zero),\r\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\r\n        };\r\n    }\r\n};\r\nexport function parseTagFlags(flags) {\r\n    return {\r\n        containsHeader: isBitSet(flags, 31),\r\n        containsFooter: isBitSet(flags, 30),\r\n        isHeader: isBitSet(flags, 29),\r\n        readOnly: isBitSet(flags, 0),\r\n        dataType: (flags & 6) >> 1\r\n    };\r\n}\r\n/**\r\n * @param num {number}\r\n * @param bit 0 is least significant bit (LSB)\r\n * @return {boolean} true if bit is 1; otherwise false\r\n */\r\nexport function isBitSet(num, bit) {\r\n    return (num & 1 << bit) !== 0;\r\n}\r\n//# sourceMappingURL=APEv2Token.js.map"],
  "mappings": "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",
  "names": ["DataType", "initDebug"]
}
