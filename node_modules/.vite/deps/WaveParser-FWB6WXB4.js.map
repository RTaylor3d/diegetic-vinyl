{
  "version": 3,
  "sources": ["../../music-metadata/lib/wav/WaveParser.js", "../../music-metadata/lib/riff/RiffChunk.js", "../../music-metadata/lib/wav/WaveChunk.js", "../../music-metadata/lib/wav/BwfChunk.js"],
  "sourcesContent": ["import * as strtok3 from 'strtok3';\r\nimport * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as riff from '../riff/RiffChunk.js';\r\nimport * as WaveChunk from './WaveChunk.js';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport * as util from '../common/Util.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { BroadcastAudioExtensionChunk } from './BwfChunk.js';\r\nimport { WaveContentError } from './WaveChunk.js';\r\nconst debug = initDebug('music-metadata:parser:RIFF');\r\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n * - http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n * ToDo: Split WAVE part from RIFF parser\r\n */\r\nexport class WaveParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.blockAlign = 0;\r\n    }\r\n    async parse() {\r\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\r\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\r\n        if (riffHeader.chunkID !== 'RIFF')\r\n            return; // Not RIFF format\r\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\r\n            if (!(err instanceof strtok3.EndOfStreamError)) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    async parseRiffChunk(chunkSize) {\r\n        const type = await this.tokenizer.readToken(FourCcToken);\r\n        this.metadata.setFormat('container', type);\r\n        switch (type) {\r\n            case 'WAVE':\r\n                return this.readWaveChunk(chunkSize - FourCcToken.len);\r\n            default:\r\n                throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);\r\n        }\r\n    }\r\n    async readWaveChunk(remaining) {\r\n        while (remaining >= riff.Header.len) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            remaining -= riff.Header.len + header.chunkSize;\r\n            if (header.chunkSize > remaining) {\r\n                this.metadata.addWarning('Data chunk size exceeds file size');\r\n            }\r\n            this.header = header;\r\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\r\n            switch (header.chunkID) {\r\n                case 'LIST':\r\n                    await this.parseListTag(header);\r\n                    break;\r\n                case 'fact': // extended Format chunk,\r\n                    this.metadata.setFormat('lossless', false);\r\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\r\n                    break;\r\n                case 'fmt ': { // The Util Chunk, non-PCM Formats\r\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\r\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\r\n                    if (!subFormat) {\r\n                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);\r\n                        subFormat = `non-PCM (${fmt.wFormatTag})`;\r\n                    }\r\n                    this.metadata.setFormat('codec', subFormat);\r\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\r\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\r\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\r\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\r\n                    this.blockAlign = fmt.nBlockAlign;\r\n                    break;\r\n                }\r\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\r\n                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data\r\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\r\n                    const rst = strtok3.fromBuffer(id3_data);\r\n                    await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                    break;\r\n                }\r\n                case 'data': { // PCM-data\r\n                    if (this.metadata.format.lossless !== false) {\r\n                        this.metadata.setFormat('lossless', true);\r\n                    }\r\n                    let chunkSize = header.chunkSize;\r\n                    if (this.tokenizer.fileInfo.size) {\r\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n                        if (calcRemaining < chunkSize) {\r\n                            this.metadata.addWarning('data chunk length exceeding file length');\r\n                            chunkSize = calcRemaining;\r\n                        }\r\n                    }\r\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\r\n                    if (numberOfSamples) {\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        if (this.metadata.format.sampleRate) {\r\n                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\r\n                        }\r\n                    }\r\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\r\n                        this.metadata.setFormat('bitrate', 352000);\r\n                    }\r\n                    else if (this.metadata.format.sampleRate) {\r\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\r\n                    }\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                }\r\n                case 'bext': { // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\r\n                    const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);\r\n                    Object.keys(bext).forEach(key => {\r\n                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);\r\n                    });\r\n                    const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;\r\n                    await this.tokenizer.ignore(bextRemaining);\r\n                    break;\r\n                }\r\n                case '\\x00\\x00\\x00\\x00': // padding ??\r\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                default:\r\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n            }\r\n            if (this.header.chunkSize % 2 === 1) {\r\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\r\n                await this.tokenizer.ignore(1);\r\n            }\r\n        }\r\n    }\r\n    async parseListTag(listHeader) {\r\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'latin1'));\r\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\r\n        switch (listType) {\r\n            case 'INFO':\r\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\r\n            default:\r\n                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);\r\n                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);\r\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\r\n        }\r\n    }\r\n    async parseRiffInfoTags(chunkSize) {\r\n        while (chunkSize >= 8) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            const valueToken = new riff.ListInfoTagValue(header);\r\n            const value = await this.tokenizer.readToken(valueToken);\r\n            this.addTag(header.chunkID, util.stripNulls(value));\r\n            chunkSize -= (8 + valueToken.len);\r\n        }\r\n        if (chunkSize !== 0) {\r\n            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag('exif', id, value);\r\n    }\r\n}\r\n//# sourceMappingURL=WaveParser.js.map", "import * as Token from 'token-types';\r\n/**\r\n * Common RIFF chunk header\r\n */\r\nexport const Header = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Group-ID\r\n            chunkID: new Token.StringType(4, 'latin1').get(buf, off),\r\n            // Size\r\n            chunkSize: Token.UINT32_LE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Token to parse RIFF-INFO tag value\r\n */\r\nexport class ListInfoTagValue {\r\n    constructor(tagHeader) {\r\n        this.tagHeader = tagHeader;\r\n        this.len = tagHeader.chunkSize;\r\n        this.len += this.len & 1; // if it is an odd length, round up to even\r\n    }\r\n    get(buf, off) {\r\n        return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);\r\n    }\r\n}\r\n//# sourceMappingURL=RiffChunk.js.map", "import * as Token from 'token-types';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nexport class WaveContentError extends makeUnexpectedFileContentError('Wave') {\r\n}\r\n/**\r\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx\r\n */\r\nexport var WaveFormat;\r\n(function (WaveFormat) {\r\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\r\n    // MPEG-4 and AAC Audio Types\r\n    WaveFormat[WaveFormat[\"ADPCM\"] = 2] = \"ADPCM\";\r\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\r\n    WaveFormat[WaveFormat[\"MPEG_ADTS_AAC\"] = 5632] = \"MPEG_ADTS_AAC\";\r\n    WaveFormat[WaveFormat[\"MPEG_LOAS\"] = 5634] = \"MPEG_LOAS\";\r\n    WaveFormat[WaveFormat[\"RAW_AAC1\"] = 255] = \"RAW_AAC1\";\r\n    // Dolby Audio Types\r\n    WaveFormat[WaveFormat[\"DOLBY_AC3_SPDIF\"] = 146] = \"DOLBY_AC3_SPDIF\";\r\n    WaveFormat[WaveFormat[\"DVM\"] = 8192] = \"DVM\";\r\n    WaveFormat[WaveFormat[\"RAW_SPORT\"] = 576] = \"RAW_SPORT\";\r\n    WaveFormat[WaveFormat[\"ESST_AC3\"] = 577] = \"ESST_AC3\";\r\n    WaveFormat[WaveFormat[\"DRM\"] = 9] = \"DRM\";\r\n    WaveFormat[WaveFormat[\"DTS2\"] = 8193] = \"DTS2\";\r\n    WaveFormat[WaveFormat[\"MPEG\"] = 80] = \"MPEG\";\r\n})(WaveFormat || (WaveFormat = {}));\r\n/**\r\n * format chunk; chunk-id is \"fmt \"\r\n * http://soundfile.sapp.org/doc/WaveFormat/\r\n */\r\nexport class Format {\r\n    constructor(header) {\r\n        if (header.chunkSize < 16)\r\n            throw new WaveContentError('Invalid chunk size');\r\n        this.len = header.chunkSize;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            wFormatTag: Token.UINT16_LE.get(buf, off),\r\n            nChannels: Token.UINT16_LE.get(buf, off + 2),\r\n            nSamplesPerSec: Token.UINT32_LE.get(buf, off + 4),\r\n            nAvgBytesPerSec: Token.UINT32_LE.get(buf, off + 8),\r\n            nBlockAlign: Token.UINT16_LE.get(buf, off + 12),\r\n            wBitsPerSample: Token.UINT16_LE.get(buf, off + 14)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Fact chunk; chunk-id is \"fact\"\r\n * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\r\n * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file\r\n */\r\nexport class FactChunk {\r\n    constructor(header) {\r\n        if (header.chunkSize < 4) {\r\n            throw new WaveContentError('Invalid fact chunk size.');\r\n        }\r\n        this.len = header.chunkSize;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            dwSampleLength: Token.UINT32_LE.get(buf, off)\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=WaveChunk.js.map", "import * as Token from 'token-types';\r\nimport { stripNulls } from '../common/Util.js';\r\n/**\r\n * Broadcast Audio Extension Chunk\r\n * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf\r\n */\r\nexport const BroadcastAudioExtensionChunk = {\r\n    len: 420,\r\n    get: (uint8array, off) => {\r\n        return {\r\n            description: stripNulls(new Token.StringType(256, 'ascii').get(uint8array, off)).trim(),\r\n            originator: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),\r\n            originatorReference: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),\r\n            originationDate: stripNulls(new Token.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),\r\n            originationTime: stripNulls(new Token.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),\r\n            timeReferenceLow: Token.UINT32_LE.get(uint8array, off + 338),\r\n            timeReferenceHigh: Token.UINT32_LE.get(uint8array, off + 342),\r\n            version: Token.UINT16_LE.get(uint8array, off + 346),\r\n            umid: new Token.Uint8ArrayType(64).get(uint8array, off + 348),\r\n            loudnessValue: Token.UINT16_LE.get(uint8array, off + 412),\r\n            maxTruePeakLevel: Token.UINT16_LE.get(uint8array, off + 414),\r\n            maxMomentaryLoudness: Token.UINT16_LE.get(uint8array, off + 416),\r\n            maxShortTermLoudness: Token.UINT16_LE.get(uint8array, off + 418)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=BwfChunk.js.map"],
  "mappings": "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",
  "names": ["WaveFormat", "initDebug"]
}
