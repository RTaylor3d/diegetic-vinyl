{
  "version": 3,
  "sources": ["../../music-metadata/lib/ogg/OggParser.js", "../../music-metadata/lib/ogg/opus/Opus.js", "../../music-metadata/lib/ogg/opus/OpusParser.js", "../../music-metadata/lib/ogg/speex/SpeexParser.js", "../../music-metadata/lib/ogg/speex/Speex.js", "../../music-metadata/lib/ogg/theora/TheoraParser.js", "../../music-metadata/lib/ogg/theora/Theora.js"],
  "sourcesContent": ["import * as Token from 'token-types';\r\nimport { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport * as util from '../common/Util.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { VorbisParser } from './vorbis/VorbisParser.js';\r\nimport { OpusParser } from './opus/OpusParser.js';\r\nimport { SpeexParser } from './speex/SpeexParser.js';\r\nimport { TheoraParser } from './theora/TheoraParser.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\r\n}\r\nconst debug = initDebug('music-metadata:parser:ogg');\r\nexport class SegmentTable {\r\n    static sum(buf, off, len) {\r\n        const dv = new DataView(buf.buffer, 0);\r\n        let s = 0;\r\n        for (let i = off; i < off + len; ++i) {\r\n            s += dv.getUint8(i);\r\n        }\r\n        return s;\r\n    }\r\n    constructor(header) {\r\n        this.len = header.page_segments;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Parser for Ogg logical bitstream framing\r\n */\r\nexport class OggParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.header = null;\r\n        this.pageNumber = 0;\r\n        this.pageConsumer = null;\r\n    }\r\n    /**\r\n     * Parse page\r\n     * @returns {Promise<void>}\r\n     */\r\n    async parse() {\r\n        debug('pos=%s, parsePage()', this.tokenizer.position);\r\n        try {\r\n            let header;\r\n            do {\r\n                header = await this.tokenizer.readToken(OggParser.Header);\r\n                if (header.capturePattern !== 'OggS')\r\n                    throw new OggContentError('Invalid Ogg capture pattern');\r\n                this.metadata.setFormat('container', 'Ogg');\r\n                this.header = header;\r\n                this.pageNumber = header.pageSequenceNo;\r\n                debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);\r\n                const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));\r\n                debug('totalPageSize=%s', segmentTable.totalPageSize);\r\n                const pageData = await this.tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\r\n                debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\r\n                if (header.headerType.firstPage) {\r\n                    const id = new TextDecoder('ascii').decode(pageData.subarray(0, 7));\r\n                    switch (id) {\r\n                        case '\\x01vorbis': // Ogg/Vorbis\r\n                            debug('Set page consumer to Ogg/Vorbis');\r\n                            this.pageConsumer = new VorbisParser(this.metadata, this.options);\r\n                            break;\r\n                        case 'OpusHea': // Ogg/Opus\r\n                            debug('Set page consumer to Ogg/Opus');\r\n                            this.pageConsumer = new OpusParser(this.metadata, this.options, this.tokenizer);\r\n                            break;\r\n                        case 'Speex  ': // Ogg/Speex\r\n                            debug('Set page consumer to Ogg/Speex');\r\n                            this.pageConsumer = new SpeexParser(this.metadata, this.options, this.tokenizer);\r\n                            break;\r\n                        case 'fishead':\r\n                        case '\\x00theora': // Ogg/Theora\r\n                            debug('Set page consumer to Ogg/Theora');\r\n                            this.pageConsumer = new TheoraParser(this.metadata, this.options, this.tokenizer);\r\n                            break;\r\n                        default:\r\n                            throw new OggContentError(`gg audio-codec not recognized (id=${id})`);\r\n                    }\r\n                }\r\n                await this.pageConsumer.parsePage(header, pageData);\r\n            } while (!header.headerType.lastPage);\r\n        }\r\n        catch (err) {\r\n            if (err instanceof Error) {\r\n                if (err instanceof EndOfStreamError) {\r\n                    this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\r\n                    debug(\"End-of-stream\");\r\n                    this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\r\n                    if (this.header) {\r\n                        this.pageConsumer.calculateDuration(this.header);\r\n                    }\r\n                }\r\n                else if (err.message.startsWith('FourCC')) {\r\n                    if (this.pageNumber > 0) {\r\n                        // ignore this error: work-around if last OGG-page is not marked with last-page flag\r\n                        this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');\r\n                        await this.pageConsumer.flush();\r\n                    }\r\n                }\r\n            }\r\n            else\r\n                throw err;\r\n        }\r\n    }\r\n}\r\nOggParser.Header = {\r\n    len: 27,\r\n    get: (buf, off) => {\r\n        return {\r\n            capturePattern: FourCcToken.get(buf, off),\r\n            version: Token.UINT8.get(buf, off + 4),\r\n            headerType: {\r\n                continued: util.getBit(buf, off + 5, 0),\r\n                firstPage: util.getBit(buf, off + 5, 1),\r\n                lastPage: util.getBit(buf, off + 5, 2)\r\n            },\r\n            // packet_flag: Token.UINT8.get(buf, off + 5),\r\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\r\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\r\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\r\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\r\n            page_segments: Token.UINT8.get(buf, off + 26)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=OggParser.js.map", "import * as Token from 'token-types';\r\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\r\nexport class OpusContentError extends makeUnexpectedFileContentError('Opus') {\r\n}\r\n/**\r\n * Opus ID Header parser\r\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\r\n */\r\nexport class IdHeader {\r\n    constructor(len) {\r\n        this.len = len;\r\n        if (len < 19) {\r\n            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');\r\n        }\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\r\n            version: Token.UINT8.get(buf, off + 8),\r\n            channelCount: Token.UINT8.get(buf, off + 9),\r\n            preSkip: Token.UINT16_LE.get(buf, off + 10),\r\n            inputSampleRate: Token.UINT32_LE.get(buf, off + 12),\r\n            outputGain: Token.UINT16_LE.get(buf, off + 16),\r\n            channelMapping: Token.UINT8.get(buf, off + 18)\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=Opus.js.map", "import * as Token from 'token-types';\r\nimport { VorbisParser } from '../vorbis/VorbisParser.js';\r\nimport * as Opus from './Opus.js';\r\nimport { OpusContentError } from './Opus.js';\r\n/**\r\n * Opus parser\r\n * Internet Engineering Task Force (IETF) - RFC 6716\r\n * Used by OggParser\r\n */\r\nexport class OpusParser extends VorbisParser {\r\n    constructor(metadata, options, tokenizer) {\r\n        super(metadata, options);\r\n        this.tokenizer = tokenizer;\r\n        this.idHeader = null;\r\n        this.lastPos = -1;\r\n    }\r\n    /**\r\n     * Parse first Opus Ogg page\r\n     * @param {IPageHeader} header\r\n     * @param {Uint8Array} pageData\r\n     */\r\n    parseFirstPage(header, pageData) {\r\n        this.metadata.setFormat('codec', 'Opus');\r\n        // Parse Opus ID Header\r\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\r\n        if (this.idHeader.magicSignature !== \"OpusHead\")\r\n            throw new OpusContentError(\"Illegal ogg/Opus magic-signature\");\r\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\r\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\r\n    }\r\n    async parseFullPage(pageData) {\r\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\r\n        switch (magicSignature) {\r\n            case 'OpusTags':\r\n                await this.parseUserCommentList(pageData, 8);\r\n                this.lastPos = this.tokenizer.position - pageData.length;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    calculateDuration(header) {\r\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\r\n            // Calculate duration\r\n            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;\r\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\r\n            this.metadata.setFormat('duration', pos_48bit / 48000);\r\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\r\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\r\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=OpusParser.js.map", "import initDebug from 'debug';\r\nimport { VorbisParser } from '../vorbis/VorbisParser.js';\r\nimport * as Speex from './Speex.js';\r\nconst debug = initDebug('music-metadata:parser:ogg:speex');\r\n/**\r\n * Speex, RFC 5574\r\n * Ref:\r\n * - https://www.speex.org/docs/manual/speex-manual/\r\n * - https://tools.ietf.org/html/rfc5574\r\n */\r\nexport class SpeexParser extends VorbisParser {\r\n    constructor(metadata, options, tokenizer) {\r\n        super(metadata, options);\r\n        this.tokenizer = tokenizer;\r\n    }\r\n    /**\r\n     * Parse first Speex Ogg page\r\n     * @param {IPageHeader} header\r\n     * @param {Uint8Array} pageData\r\n     */\r\n    parseFirstPage(header, pageData) {\r\n        debug('First Ogg/Speex page');\r\n        const speexHeader = Speex.Header.get(pageData, 0);\r\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\r\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\r\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\r\n        if (speexHeader.bitrate !== -1) {\r\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=SpeexParser.js.map", "import * as Token from 'token-types';\r\nimport * as util from '../../common/Util.js';\r\n/**\r\n * Speex Header Packet\r\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\r\n */\r\nexport const Header = {\r\n    len: 80,\r\n    get: (buf, off) => {\r\n        return {\r\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\r\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\r\n            version_id: Token.INT32_LE.get(buf, off + 28),\r\n            header_size: Token.INT32_LE.get(buf, off + 32),\r\n            rate: Token.INT32_LE.get(buf, off + 36),\r\n            mode: Token.INT32_LE.get(buf, off + 40),\r\n            mode_bitstream_version: Token.INT32_LE.get(buf, off + 44),\r\n            nb_channels: Token.INT32_LE.get(buf, off + 48),\r\n            bitrate: Token.INT32_LE.get(buf, off + 52),\r\n            frame_size: Token.INT32_LE.get(buf, off + 56),\r\n            vbr: Token.INT32_LE.get(buf, off + 60),\r\n            frames_per_packet: Token.INT32_LE.get(buf, off + 64),\r\n            extra_headers: Token.INT32_LE.get(buf, off + 68),\r\n            reserved1: Token.INT32_LE.get(buf, off + 72),\r\n            reserved2: Token.INT32_LE.get(buf, off + 76)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=Speex.js.map", "import initDebug from 'debug';\r\nimport { IdentificationHeader } from './Theora.js';\r\nconst debug = initDebug('music-metadata:parser:ogg:theora');\r\n/**\r\n * Ref:\r\n * - https://theora.org/doc/Theora.pdf\r\n */\r\nexport class TheoraParser {\r\n    constructor(metadata, options, tokenizer) {\r\n        this.metadata = metadata;\r\n        this.tokenizer = tokenizer;\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    async parsePage(header, pageData) {\r\n        if (header.headerType.firstPage) {\r\n            await this.parseFirstPage(header, pageData);\r\n        }\r\n    }\r\n    async flush() {\r\n        debug('flush');\r\n    }\r\n    calculateDuration(header) {\r\n        debug('duration calculation not implemented');\r\n    }\r\n    /**\r\n     * Parse first Theora Ogg page. the initial identification header packet\r\n     * @param {IPageHeader} header\r\n     * @param {Buffer} pageData\r\n     */\r\n    async parseFirstPage(header, pageData) {\r\n        debug('First Ogg/Theora page');\r\n        this.metadata.setFormat('codec', 'Theora');\r\n        const idHeader = IdentificationHeader.get(pageData, 0);\r\n        this.metadata.setFormat('bitrate', idHeader.nombr);\r\n    }\r\n}\r\n//# sourceMappingURL=TheoraParser.js.map", "import * as Token from 'token-types';\r\n/**\r\n * 6.2 Identification Header\r\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\r\n */\r\nexport const IdentificationHeader = {\r\n    len: 42,\r\n    get: (buf, off) => {\r\n        return {\r\n            id: new Token.StringType(7, 'ascii').get(buf, off),\r\n            vmaj: Token.UINT8.get(buf, off + 7),\r\n            vmin: Token.UINT8.get(buf, off + 8),\r\n            vrev: Token.UINT8.get(buf, off + 9),\r\n            vmbw: Token.UINT16_BE.get(buf, off + 10),\r\n            vmbh: Token.UINT16_BE.get(buf, off + 17),\r\n            nombr: Token.UINT24_BE.get(buf, off + 37),\r\n            nqual: Token.UINT8.get(buf, off + 40)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=Theora.js.map"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAAA,gBAAsB;;;ACAf,IAAM,mBAAN,cAA+B,+BAA+B,MAAM,EAAE;AAC7E;AAKO,IAAM,WAAN,MAAe;AAAA,EAClB,YAAY,KAAK;AACb,SAAK,MAAM;AACX,QAAI,MAAM,IAAI;AACV,YAAM,IAAI,iBAAiB,mDAAmD;AAAA,IAClF;AAAA,EACJ;AAAA,EACA,IAAI,KAAK,KAAK;AACV,WAAO;AAAA,MACH,gBAAgB,IAAU,WAAW,GAAG,OAAO,EAAE,IAAI,KAAK,MAAM,CAAC;AAAA,MACjE,SAAe,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MACrC,cAAoB,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MAC1C,SAAe,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MAC1C,iBAAuB,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MAClD,YAAkB,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MAC7C,gBAAsB,MAAM,IAAI,KAAK,MAAM,EAAE;AAAA,IACjD;AAAA,EACJ;AACJ;;;ACjBO,IAAM,aAAN,cAAyB,aAAa;AAAA,EACzC,YAAY,UAAU,SAAS,WAAW;AACtC,UAAM,UAAU,OAAO;AACvB,SAAK,YAAY;AACjB,SAAK,WAAW;AAChB,SAAK,UAAU;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,QAAQ,UAAU;AAC7B,SAAK,SAAS,UAAU,SAAS,MAAM;AAEvC,SAAK,WAAW,IAAS,SAAS,SAAS,MAAM,EAAE,IAAI,UAAU,CAAC;AAClE,QAAI,KAAK,SAAS,mBAAmB;AACjC,YAAM,IAAI,iBAAiB,kCAAkC;AACjE,SAAK,SAAS,UAAU,cAAc,KAAK,SAAS,eAAe;AACnE,SAAK,SAAS,UAAU,oBAAoB,KAAK,SAAS,YAAY;AAAA,EAC1E;AAAA,EACA,MAAM,cAAc,UAAU;AAC1B,UAAM,iBAAiB,IAAU,WAAW,GAAG,OAAO,EAAE,IAAI,UAAU,CAAC;AACvE,YAAQ,gBAAgB;AAAA,MACpB,KAAK;AACD,cAAM,KAAK,qBAAqB,UAAU,CAAC;AAC3C,aAAK,UAAU,KAAK,UAAU,WAAW,SAAS;AAClD;AAAA,MACJ;AACI;AAAA,IACR;AAAA,EACJ;AAAA,EACA,kBAAkB,QAAQ;AACtB,QAAI,KAAK,SAAS,OAAO,cAAc,OAAO,2BAA2B,GAAG;AAExE,YAAM,YAAY,OAAO,0BAA0B,KAAK,SAAS;AACjE,WAAK,SAAS,UAAU,mBAAmB,SAAS;AACpD,WAAK,SAAS,UAAU,YAAY,YAAY,IAAK;AACrD,UAAI,KAAK,YAAY,MAAM,KAAK,UAAU,SAAS,QAAQ,KAAK,SAAS,OAAO,UAAU;AACtF,cAAM,WAAW,KAAK,UAAU,SAAS,OAAO,KAAK;AACrD,aAAK,SAAS,UAAU,WAAW,IAAI,WAAW,KAAK,SAAS,OAAO,QAAQ;AAAA,MACnF;AAAA,IACJ;AAAA,EACJ;AACJ;;;ACrDA,mBAAsB;;;ACMf,IAAM,SAAS;AAAA,EAClB,KAAK;AAAA,EACL,KAAK,CAAC,KAAK,QAAQ;AACf,WAAO;AAAA,MACH,OAAO,IAAU,WAAW,GAAG,OAAO,EAAE,IAAI,KAAK,MAAM,CAAC;AAAA,MACxD,SAAc,cAAc,IAAU,WAAW,IAAI,OAAO,EAAE,IAAI,KAAK,MAAM,CAAC,CAAC;AAAA,MAC/E,YAAkB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MAC5C,aAAmB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MAC7C,MAAY,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MACtC,MAAY,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MACtC,wBAA8B,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MACxD,aAAmB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MAC7C,SAAe,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MACzC,YAAkB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MAC5C,KAAW,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MACrC,mBAAyB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MACnD,eAAqB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MAC/C,WAAiB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,MAC3C,WAAiB,SAAS,IAAI,KAAK,MAAM,EAAE;AAAA,IAC/C;AAAA,EACJ;AACJ;;;ADxBA,IAAM,YAAQ,aAAAC,SAAU,iCAAiC;AAOlD,IAAM,cAAN,cAA0B,aAAa;AAAA,EAC1C,YAAY,UAAU,SAAS,WAAW;AACtC,UAAM,UAAU,OAAO;AACvB,SAAK,YAAY;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,QAAQ,UAAU;AAC7B,UAAM,sBAAsB;AAC5B,UAAM,cAAoB,OAAO,IAAI,UAAU,CAAC;AAChD,SAAK,SAAS,UAAU,SAAS,SAAS,YAAY,OAAO,EAAE;AAC/D,SAAK,SAAS,UAAU,oBAAoB,YAAY,WAAW;AACnE,SAAK,SAAS,UAAU,cAAc,YAAY,IAAI;AACtD,QAAI,YAAY,YAAY,IAAI;AAC5B,WAAK,SAAS,UAAU,WAAW,YAAY,OAAO;AAAA,IAC1D;AAAA,EACJ;AACJ;;;AE9BA,IAAAC,gBAAsB;;;ACKf,IAAM,uBAAuB;AAAA,EAChC,KAAK;AAAA,EACL,KAAK,CAAC,KAAK,QAAQ;AACf,WAAO;AAAA,MACH,IAAI,IAAU,WAAW,GAAG,OAAO,EAAE,IAAI,KAAK,GAAG;AAAA,MACjD,MAAY,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MAClC,MAAY,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MAClC,MAAY,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MAClC,MAAY,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MACvC,MAAY,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MACvC,OAAa,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MACxC,OAAa,MAAM,IAAI,KAAK,MAAM,EAAE;AAAA,IACxC;AAAA,EACJ;AACJ;;;ADjBA,IAAMC,aAAQ,cAAAC,SAAU,kCAAkC;AAKnD,IAAM,eAAN,MAAmB;AAAA,EACtB,YAAY,UAAU,SAAS,WAAW;AACtC,SAAK,WAAW;AAChB,SAAK,YAAY;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,UAAU,QAAQ,UAAU;AAC9B,QAAI,OAAO,WAAW,WAAW;AAC7B,YAAM,KAAK,eAAe,QAAQ,QAAQ;AAAA,IAC9C;AAAA,EACJ;AAAA,EACA,MAAM,QAAQ;AACV,IAAAD,OAAM,OAAO;AAAA,EACjB;AAAA,EACA,kBAAkB,QAAQ;AACtB,IAAAA,OAAM,sCAAsC;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,eAAe,QAAQ,UAAU;AACnC,IAAAA,OAAM,uBAAuB;AAC7B,SAAK,SAAS,UAAU,SAAS,QAAQ;AACzC,UAAM,WAAW,qBAAqB,IAAI,UAAU,CAAC;AACrD,SAAK,SAAS,UAAU,WAAW,SAAS,KAAK;AAAA,EACrD;AACJ;;;AL5BO,IAAM,kBAAN,cAA8B,+BAA+B,KAAK,EAAE;AAC3E;AACA,IAAME,aAAQ,cAAAC,SAAU,2BAA2B;AAC5C,IAAM,eAAN,MAAM,cAAa;AAAA,EACtB,OAAO,IAAI,KAAK,KAAK,KAAK;AACtB,UAAM,KAAK,IAAI,SAAS,IAAI,QAAQ,CAAC;AACrC,QAAI,IAAI;AACR,aAAS,IAAI,KAAK,IAAI,MAAM,KAAK,EAAE,GAAG;AAClC,WAAK,GAAG,SAAS,CAAC;AAAA,IACtB;AACA,WAAO;AAAA,EACX;AAAA,EACA,YAAY,QAAQ;AAChB,SAAK,MAAM,OAAO;AAAA,EACtB;AAAA,EACA,IAAI,KAAK,KAAK;AACV,WAAO;AAAA,MACH,eAAe,cAAa,IAAI,KAAK,KAAK,KAAK,GAAG;AAAA,IACtD;AAAA,EACJ;AACJ;AAIO,IAAM,YAAN,MAAM,mBAAkB,YAAY;AAAA,EACvC,cAAc;AACV,UAAM,GAAG,SAAS;AAClB,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACV,IAAAD,OAAM,uBAAuB,KAAK,UAAU,QAAQ;AACpD,QAAI;AACA,UAAI;AACJ,SAAG;AACC,iBAAS,MAAM,KAAK,UAAU,UAAU,WAAU,MAAM;AACxD,YAAI,OAAO,mBAAmB;AAC1B,gBAAM,IAAI,gBAAgB,6BAA6B;AAC3D,aAAK,SAAS,UAAU,aAAa,KAAK;AAC1C,aAAK,SAAS;AACd,aAAK,aAAa,OAAO;AACzB,QAAAA,OAAM,uBAAuB,OAAO,gBAAgB,OAAO,cAAc;AACzE,cAAM,eAAe,MAAM,KAAK,UAAU,UAAU,IAAI,aAAa,MAAM,CAAC;AAC5E,QAAAA,OAAM,oBAAoB,aAAa,aAAa;AACpD,cAAM,WAAW,MAAM,KAAK,UAAU,UAAU,IAAU,eAAe,aAAa,aAAa,CAAC;AACpG,QAAAA,OAAM,2CAA2C,OAAO,WAAW,WAAW,OAAO,WAAW,UAAU,OAAO,WAAW,SAAS;AACrI,YAAI,OAAO,WAAW,WAAW;AAC7B,gBAAM,KAAK,IAAI,YAAY,OAAO,EAAE,OAAO,SAAS,SAAS,GAAG,CAAC,CAAC;AAClE,kBAAQ,IAAI;AAAA,YACR,KAAK;AACD,cAAAA,OAAM,iCAAiC;AACvC,mBAAK,eAAe,IAAI,aAAa,KAAK,UAAU,KAAK,OAAO;AAChE;AAAA,YACJ,KAAK;AACD,cAAAA,OAAM,+BAA+B;AACrC,mBAAK,eAAe,IAAI,WAAW,KAAK,UAAU,KAAK,SAAS,KAAK,SAAS;AAC9E;AAAA,YACJ,KAAK;AACD,cAAAA,OAAM,gCAAgC;AACtC,mBAAK,eAAe,IAAI,YAAY,KAAK,UAAU,KAAK,SAAS,KAAK,SAAS;AAC/E;AAAA,YACJ,KAAK;AAAA,YACL,KAAK;AACD,cAAAA,OAAM,iCAAiC;AACvC,mBAAK,eAAe,IAAI,aAAa,KAAK,UAAU,KAAK,SAAS,KAAK,SAAS;AAChF;AAAA,YACJ;AACI,oBAAM,IAAI,gBAAgB,qCAAqC,EAAE,GAAG;AAAA,UAC5E;AAAA,QACJ;AACA,cAAM,KAAK,aAAa,UAAU,QAAQ,QAAQ;AAAA,MACtD,SAAS,CAAC,OAAO,WAAW;AAAA,IAChC,SACO,KAAK;AACR,UAAI,eAAe,OAAO;AACtB,YAAI,eAAe,kBAAkB;AACjC,eAAK,SAAS,WAAW,iDAAiD;AAC1E,UAAAA,OAAM,eAAe;AACrB,eAAK,SAAS,WAAW,iDAAiD;AAC1E,cAAI,KAAK,QAAQ;AACb,iBAAK,aAAa,kBAAkB,KAAK,MAAM;AAAA,UACnD;AAAA,QACJ,WACS,IAAI,QAAQ,WAAW,QAAQ,GAAG;AACvC,cAAI,KAAK,aAAa,GAAG;AAErB,iBAAK,SAAS,WAAW,0EAA0E;AACnG,kBAAM,KAAK,aAAa,MAAM;AAAA,UAClC;AAAA,QACJ;AAAA,MACJ;AAEI,cAAM;AAAA,IACd;AAAA,EACJ;AACJ;AACA,UAAU,SAAS;AAAA,EACf,KAAK;AAAA,EACL,KAAK,CAAC,KAAK,QAAQ;AACf,WAAO;AAAA,MACH,gBAAgB,YAAY,IAAI,KAAK,GAAG;AAAA,MACxC,SAAe,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MACrC,YAAY;AAAA,QACR,WAAgB,OAAO,KAAK,MAAM,GAAG,CAAC;AAAA,QACtC,WAAgB,OAAO,KAAK,MAAM,GAAG,CAAC;AAAA,QACtC,UAAe,OAAO,KAAK,MAAM,GAAG,CAAC;AAAA,MACzC;AAAA;AAAA,MAEA,yBAAyB,OAAa,UAAU,IAAI,KAAK,MAAM,CAAC,CAAC;AAAA,MACjE,oBAA0B,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MACrD,gBAAsB,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MACjD,cAAoB,UAAU,IAAI,KAAK,MAAM,EAAE;AAAA,MAC/C,eAAqB,MAAM,IAAI,KAAK,MAAM,EAAE;AAAA,IAChD;AAAA,EACJ;AACJ;",
  "names": ["import_debug", "initDebug", "import_debug", "debug", "initDebug", "debug", "initDebug"]
}
