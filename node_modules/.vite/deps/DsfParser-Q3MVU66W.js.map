{
  "version": 3,
  "sources": ["../../music-metadata/lib/dsf/DsfParser.js", "../../music-metadata/lib/dsf/DsfChunk.js"],
  "sourcesContent": ["import initDebug from 'debug';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { ChunkHeader, DsdChunk, FormatChunk } from './DsfChunk.js';\r\nimport { ID3v2Parser } from \"../id3v2/ID3v2Parser.js\";\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:DSF');\r\nexport class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {\r\n}\r\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\r\nexport class DsfParser extends AbstractID3Parser {\r\n    async postId3v2Parse() {\r\n        const p0 = this.tokenizer.position; // mark start position, normally 0\r\n        const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\r\n        if (chunkHeader.id !== 'DSD ')\r\n            throw new DsdContentParseError('Invalid chunk signature');\r\n        this.metadata.setFormat('container', 'DSF');\r\n        this.metadata.setFormat('lossless', true);\r\n        const dsdChunk = await this.tokenizer.readToken(DsdChunk);\r\n        if (dsdChunk.metadataPointer === BigInt(0)) {\r\n            debug(\"No ID3v2 tag present\");\r\n        }\r\n        else {\r\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\r\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\r\n            // Jump to ID3 header\r\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\r\n            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\r\n        }\r\n    }\r\n    async parseChunks(bytesRemaining) {\r\n        while (bytesRemaining >= ChunkHeader.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\r\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\r\n            switch (chunkHeader.id) {\r\n                case 'fmt ': {\r\n                    const formatChunk = await this.tokenizer.readToken(FormatChunk);\r\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\r\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\r\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\r\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\r\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\r\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\r\n                    this.metadata.setFormat('bitrate', bitrate);\r\n                    return; // We got what we want, stop further processing of chunks\r\n                }\r\n                default:\r\n                    this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);\r\n                    break;\r\n            }\r\n            bytesRemaining -= chunkHeader.size;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=DsfParser.js.map", "import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\n/**\r\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\r\n */\r\nexport const ChunkHeader = {\r\n    len: 12,\r\n    get: (buf, off) => {\r\n        return { id: FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };\r\n    }\r\n};\r\n/**\r\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\r\n */\r\nexport const DsdChunk = {\r\n    len: 16,\r\n    get: (buf, off) => {\r\n        return {\r\n            fileSize: Token.INT64_LE.get(buf, off),\r\n            metadataPointer: Token.INT64_LE.get(buf, off + 8)\r\n        };\r\n    }\r\n};\r\nexport var ChannelType;\r\n(function (ChannelType) {\r\n    ChannelType[ChannelType[\"mono\"] = 1] = \"mono\";\r\n    ChannelType[ChannelType[\"stereo\"] = 2] = \"stereo\";\r\n    ChannelType[ChannelType[\"channels\"] = 3] = \"channels\";\r\n    ChannelType[ChannelType[\"quad\"] = 4] = \"quad\";\r\n    ChannelType[ChannelType[\"4 channels\"] = 5] = \"4 channels\";\r\n    ChannelType[ChannelType[\"5 channels\"] = 6] = \"5 channels\";\r\n    ChannelType[ChannelType[\"5.1 channels\"] = 7] = \"5.1 channels\";\r\n})(ChannelType || (ChannelType = {}));\r\n/**\r\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\r\n */\r\nexport const FormatChunk = {\r\n    len: 40,\r\n    get: (buf, off) => {\r\n        return {\r\n            formatVersion: Token.INT32_LE.get(buf, off),\r\n            formatID: Token.INT32_LE.get(buf, off + 4),\r\n            channelType: Token.INT32_LE.get(buf, off + 8),\r\n            channelNum: Token.INT32_LE.get(buf, off + 12),\r\n            samplingFrequency: Token.INT32_LE.get(buf, off + 16),\r\n            bitsPerSample: Token.INT32_LE.get(buf, off + 20),\r\n            sampleCount: Token.INT64_LE.get(buf, off + 24),\r\n            blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=DsfChunk.js.map"],
  "mappings": "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",
  "names": ["ChannelType", "initDebug"]
}
