{
  "version": 3,
  "sources": ["../../music-metadata/lib/apev2/APEv2Parser.js", "../../music-metadata/lib/apev2/APEv2Token.js"],
  "sourcesContent": ["import initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { StringType } from 'token-types';\nimport { uint8ArrayToString } from 'uint8array-extras';\nimport * as util from '../common/Util.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { DataType, DescriptorParser, Header, TagFooter, TagItemHeader } from './APEv2Token.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nexport class ApeContentError extends makeUnexpectedFileContentError('APEv2') {\n}\nexport class APEv2Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    static tryParseApeHeader(metadata, tokenizer, options) {\n        const apeParser = new APEv2Parser(metadata, tokenizer, options);\n        return apeParser.tryParseApeHeader();\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param tokenizer\n     * @param offset\n     */\n    static async findApeFooterOffset(tokenizer, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = new Uint8Array(TagFooter.len);\n        const position = tokenizer.position;\n        await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });\n        tokenizer.setPosition(position);\n        const tagFooter = TagFooter.get(apeBuf, 0);\n        if (tagFooter.ID === 'APETAGEX') {\n            if (tagFooter.flags.isHeader) {\n                debug(`APE Header found at offset=${offset - TagFooter.len}`);\n            }\n            else {\n                debug(`APE Footer found at offset=${offset - TagFooter.len}`);\n                offset -= tagFooter.size;\n            }\n            return { footer: tagFooter, offset };\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = TagFooter.get(buffer, buffer.length - TagFooter.len);\n        if (footer.ID !== preamble)\n            throw new ApeContentError('Unexpected APEv2 Footer ID preamble value');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {\n            debug(\"No APEv2 header found, end-of-file reached\");\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(TagFooter.len);\n            return this.parseTags(footer);\n        }\n        debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n        if (this.tokenizer.fileInfo.size) {\n            // Try to read the APEv2 header using just the footer-header\n            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n            const buffer = new Uint8Array(remaining);\n            await this.tokenizer.readBuffer(buffer);\n            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(DescriptorParser);\n        if (descriptor.ID !== 'MAC ')\n            throw new ApeContentError('Unexpected descriptor ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = new Uint8Array(256); // maximum tag key length\n        let bytesRemaining = footer.size - TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);\n            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case DataType.text_utf8: { // utf-8 text-string\n                    const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    await Promise.all(values.map(val => this.metadata.addTag(tagFormat, key, val)));\n                    break;\n                }\n                case DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = new Uint8Array(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = util.findZero(picData, 0, picData.length);\n                        const description = uint8ArrayToString(picData.slice(0, zero));\n                        const data = picData.slice(zero + 1);\n                        await this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                case DataType.reserved:\n                    debug(`Ignore external info ${key}`);\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        if (!this.ape.descriptor) {\n            throw new ApeContentError('Missing APE descriptor');\n        }\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\n//# sourceMappingURL=APEv2Parser.js.map", "import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\nexport var DataType;\n(function (DataType) {\n    DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n    DataType[DataType[\"binary\"] = 1] = \"binary\";\n    DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n    DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType || (DataType = {}));\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexport const DescriptorParser = {\n    len: 52,\n    get: (buf, off) => {\n        return {\n            // should equal 'MAC '\n            ID: FourCcToken.get(buf, off),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n            // the number of descriptor bytes (allows later expansion of this header)\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n            // the number of header APE_HEADER bytes\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\n            // the number of header APE_HEADER bytes\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n            // the number of header data bytes (from original file)\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n            // the number of bytes of APE frame data\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n            // the high order number of APE frame data bytes\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n            // the terminating data of the file (not including tag data)\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n            // the MD5 hash of the file (see notes for usage... it's a little tricky)\n            fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n        };\n    }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexport const Header = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n            compressionLevel: Token.UINT16_LE.get(buf, off),\n            // any format flags (for future use)\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\n            // the number of audio blocks in one frame\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n            // the number of audio blocks in the final frame\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n            // the total number of frames\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\n            // the bits per sample (typically 16)\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n            // the number of channels (1 or 2)\n            channel: Token.UINT16_LE.get(buf, off + 18),\n            // the sample rate (typically 44100)\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\n        };\n    }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexport const TagFooter = {\n    len: 32,\n    get: (buf, off) => {\n        return {\n            // should equal 'APETAGEX'\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\n            // equals CURRENT_APE_TAG_VERSION\n            version: Token.UINT32_LE.get(buf, off + 8),\n            // the complete size of the tag, including this footer (excludes header)\n            size: Token.UINT32_LE.get(buf, off + 12),\n            // the number of fields in the tag\n            fields: Token.UINT32_LE.get(buf, off + 16),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n        };\n    }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexport const TagItemHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Length of assigned value in bytes\n            size: Token.UINT32_LE.get(buf, off),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n        };\n    }\n};\nexport function parseTagFlags(flags) {\n    return {\n        containsHeader: isBitSet(flags, 31),\n        containsFooter: isBitSet(flags, 30),\n        isHeader: isBitSet(flags, 29),\n        readOnly: isBitSet(flags, 0),\n        dataType: (flags & 6) >> 1\n    };\n}\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nexport function isBitSet(num, bit) {\n    return (num & 1 << bit) !== 0;\n}\n//# sourceMappingURL=APEv2Token.js.map"],
  "mappings": "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",
  "names": ["DataType", "initDebug"]
}
