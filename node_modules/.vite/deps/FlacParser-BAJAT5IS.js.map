{
  "version": 3,
  "sources": ["../../music-metadata/lib/flac/FlacParser.js"],
  "sourcesContent": ["import { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as util from '../common/Util.js';\r\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { VorbisParser } from '../ogg/vorbis/VorbisParser.js';\r\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:FLAC');\r\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\r\n}\r\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\r\nvar BlockType;\r\n(function (BlockType) {\r\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\r\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\r\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\r\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\r\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\r\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\r\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\r\n})(BlockType || (BlockType = {}));\r\nexport class FlacParser extends AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.vorbisParser = new VorbisParser(this.metadata, this.options);\r\n        this.padding = 0;\r\n    }\r\n    async postId3v2Parse() {\r\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\r\n        if (fourCC.toString() !== 'fLaC') {\r\n            throw new FlacContentError('Invalid FLAC preamble');\r\n        }\r\n        let blockHeader;\r\n        do {\r\n            // Read block header\r\n            blockHeader = await this.tokenizer.readToken(BlockHeader);\r\n            // Parse block data\r\n            await this.parseDataBlock(blockHeader);\r\n        } while (!blockHeader.lastBlock);\r\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\r\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\r\n        }\r\n    }\r\n    async parseDataBlock(blockHeader) {\r\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\r\n        switch (blockHeader.type) {\r\n            case BlockType.STREAMINFO:\r\n                return this.parseBlockStreamInfo(blockHeader.length);\r\n            case BlockType.PADDING:\r\n                this.padding += blockHeader.length;\r\n                break;\r\n            case BlockType.APPLICATION:\r\n                break;\r\n            case BlockType.SEEKTABLE:\r\n                break;\r\n            case BlockType.VORBIS_COMMENT:\r\n                return this.parseComment(blockHeader.length);\r\n            case BlockType.CUESHEET:\r\n                break;\r\n            case BlockType.PICTURE:\r\n                await this.parsePicture(blockHeader.length);\r\n                return;\r\n            default:\r\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\r\n        }\r\n        // Ignore data block\r\n        return this.tokenizer.ignore(blockHeader.length).then();\r\n    }\r\n    /**\r\n     * Parse STREAMINFO\r\n     */\r\n    async parseBlockStreamInfo(dataLen) {\r\n        if (dataLen !== BlockStreamInfo.len)\r\n            throw new FlacContentError('Unexpected block-stream-info length');\r\n        const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);\r\n        this.metadata.setFormat('container', 'FLAC');\r\n        this.metadata.setFormat('codec', 'FLAC');\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\r\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\r\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\r\n        if (streamInfo.totalSamples > 0) {\r\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Parse VORBIS_COMMENT\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\r\n    async parseComment(dataLen) {\r\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\r\n        const decoder = new VorbisDecoder(data, 0);\r\n        decoder.readStringUtf8(); // vendor (skip)\r\n        const commentListLength = decoder.readInt32();\r\n        const tags = new Array(commentListLength);\r\n        for (let i = 0; i < commentListLength; i++) {\r\n            tags[i] = decoder.parseUserComment();\r\n        }\r\n        await Promise.all(tags.map(tag => this.vorbisParser.addTag(tag.key, tag.value)));\r\n    }\r\n    async parsePicture(dataLen) {\r\n        if (this.options.skipCovers) {\r\n            return this.tokenizer.ignore(dataLen);\r\n        }\r\n        const picture = await this.tokenizer.readToken(new VorbisPictureToken(dataLen));\r\n        this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\r\n    }\r\n}\r\nconst BlockHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            lastBlock: util.getBit(buf, off, 7),\r\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\r\n            length: UINT24_BE.get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\r\nconst BlockStreamInfo = {\r\n    len: 34,\r\n    get: (buf, off) => {\r\n        return {\r\n            // The minimum block size (in samples) used in the stream.\r\n            minimumBlockSize: UINT16_BE.get(buf, off),\r\n            // The maximum block size (in samples) used in the stream.\r\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\r\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\r\n            // The minimum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\r\n            // The maximum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\r\n            // Sample rate in Hz. Though 20 bits are available,\r\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\r\n            // Also, a value of 0 is invalid.\r\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\r\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\r\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\r\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\r\n            // bits per sample)-1.\r\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\r\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\r\n            // Total samples in stream.\r\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\r\n            // A value of zero here means the number of total samples is unknown.\r\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\r\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=FlacParser.js.map"],
  "mappings": "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",
  "names": ["initDebug", "BlockType"]
}
